<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SequentialRobustRangingAndRssiRadioSourceEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-indoor</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.radiosource</a> &gt; <span class="el_source">SequentialRobustRangingAndRssiRadioSourceEstimator.java</span></div><h1>SequentialRobustRangingAndRssiRadioSourceEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.radiosource;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.RadioSource;
import com.irurueta.navigation.indoor.RadioSourceLocated;
import com.irurueta.navigation.indoor.RangingAndRssiReadingLocated;
import com.irurueta.navigation.indoor.RangingReadingLocated;
import com.irurueta.navigation.indoor.RssiReadingLocated;
import com.irurueta.navigation.indoor.Utils;
import com.irurueta.numerical.robust.InliersData;
import com.irurueta.numerical.robust.RobustEstimatorException;
import com.irurueta.numerical.robust.RobustEstimatorMethod;

import java.util.ArrayList;
import java.util.List;

/**
 * This is an abstract class to robustly estimate position, transmitted power and path-loss
 * exponent of a radio source (e.g. Wi-Fi access point or bluetooth beacon), by discarding
 * outliers and assuming that the ranging data is available to obtain position with
 * greater accuracy and that the radio source emits isotropically following the
 * expression below:
 * Pr = Pt*Gt*Gr*lambda^2 / (4*pi*d)^2,
 * where Pr is the received power (expressed in mW),
 * Gt is the Gain of the transmission antenna
 * Gr is the Gain of the receiver antenna
 * d is the distance between emitter and receiver
 * and lambda is the wavelength and is equal to: lambda = c / f,
 * where c is the speed of light
 * and f is the carrier frequency of the radio signal.
 * &lt;p&gt;
 * Implementations of this class sequentially estimate position and then remaining
 * parameters. First ranging data is used to robustly estimate position and then
 * remaining parameters are robustly estimated using former estimated position as
 * an initial guess.
 * &lt;p&gt;
 * Because usually information about the antenna of the radio source cannot be
 * retrieved (because many measurements are made on unknown devices where
 * physical access is not possible), this implementation will estimate the
 * equivalent transmitted power as: Pte = Pt * Gt * Gr.
 * If Readings contain RSSI standard deviations, those values will be used,
 * otherwise it will be assumed an RSSI standard deviation of 1 dB.
 * &lt;p&gt;
 * Implementations of this class might produce more stable positions of estimated
 * radio sources than implementations of RobustRangingAndRssiRadioSourceEstimator.
 *
 * @param &lt;S&gt; a {@link RadioSource} type.
 * @param &lt;P&gt; a {@link Point} type.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public abstract class SequentialRobustRangingAndRssiRadioSourceEstimator&lt;S extends RadioSource, P extends Point&lt;P&gt;&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
<span class="fc" id="L76">    public static final RobustEstimatorMethod DEFAULT_PANGING_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;</span>

    /**
     * Default robust estimator method for path-loss exponent and transmitted power
     * estimation using RSSI data when no robust method is provided.
     */
<span class="fc" id="L82">    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;</span>

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default, this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen sub-samples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that by default position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard deviation
     * assuming that both measures are statistically independent.
     */
    public static final boolean DEFAULT_USE_READING_POSITION_COVARIANCES = true;

    /**
     * Internal robust estimator for position estimation.
     */
    protected RobustRangingRadioSourceEstimator&lt;S, P&gt; rangingEstimator;

    /**
     * Internal robust estimator for path-loss exponent and transmitted power
     * estimation.
     */
    protected RobustRssiRadioSourceEstimator&lt;S, P&gt; rssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
<span class="fc" id="L158">    protected RobustEstimatorMethod rangingRobustMethod = DEFAULT_PANGING_ROBUST_METHOD;</span>

    /**
     * Robust method used for path-loss exponent and transmitted power estimation
     * using RSSI data.
     */
<span class="fc" id="L164">    protected RobustEstimatorMethod rssiRobustMethod = DEFAULT_RSSI_ROBUST_METHOD;</span>

    /**
     * Size of subsets to be checked during ranging robust estimation.
     */
    protected int rangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int rssiPreliminarySubsetSize;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     */
    protected Double rangingThreshold;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * path-loss exponent and transmitted power estimation.
     */
    protected Double rssiThreshold;

    /**
     * Signal readings belonging to the same radio source to be estimated.
     */
    private List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings;

    /**
     * Quality scores corresponding to each provided sample.
     * The larger the score value the better the quality of the sample.
     */
    private double[] qualityScores;

    /**
     * Listener to be notified of events such as when estimation starts, ends or its
     * progress significantly changes.
     */
    private SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener;

    /**
     * Estimated position.
     */
    private P estimatedPosition;

    /**
     * Indicates if this instance is locked because estimation is being executed.
     */
    private boolean locked;

    /**
     * Amount of progress variation before notifying a progress change during estimation.
     */
<span class="fc" id="L219">    private float progressDelta = DEFAULT_PROGRESS_DELTA;</span>

    /**
     * Amount of confidence expressed as a value between 0.0 and 1.0 (which is equivalent
     * to 100%) for robust position estimation. The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will be
     * close to 1.0, but not exactly 1.0.
     */
<span class="fc" id="L227">    private double rangingConfidence = DEFAULT_CONFIDENCE;</span>

    /**
     * Amount of confidence expressed as a value between 0.0 and 1.0 (which is equivalent
     * to 100%) for robust path-loss exponent and transmitted power estimation. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     */
<span class="fc" id="L235">    private double rssiConfidence = DEFAULT_CONFIDENCE;</span>

    /**
     * Maximum allowed number of iterations for robust position estimation. When the
     * maximum number of iterations is exceeded, an approximate result might be
     * available for retrieval.
     */
<span class="fc" id="L242">    private int rangingMaxIterations = DEFAULT_MAX_ITERATIONS;</span>

    /**
     * Maximum allowed number of iterations for robust path-loss exponent and transmitted
     * power estimation. When the maximum number of iterations is exceeded, an
     * approximate result might be available for retrieval.
     */
<span class="fc" id="L249">    private int rssiMaxIterations = DEFAULT_MAX_ITERATIONS;</span>

    /**
     * Indicates whether result must be refined using found inliers.
     * If true, inliers will be computed and kept in any implementation regardless of the
     * settings.
     */
<span class="fc" id="L256">    private boolean refineResult = DEFAULT_REFINE_RESULT;</span>

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     */
<span class="fc" id="L262">    private boolean keepCovariance = DEFAULT_KEEP_COVARIANCE;</span>

    /**
     * Covariance of estimated position, power and/or path-loss exponent.
     * This is only available when result has been refined and covariance is kept.
     */
    private Matrix covariance;

    /**
     * Covariance of estimated position.
     * Size of this matrix will depend on the number of dimensions
     * of estimated position (either 2 or 3).
     * This value will only be available when position estimation is enabled.
     */
    private Matrix estimatedPositionCovariance;

    /**
     * Initially transmitted power to start the estimation of radio source
     * transmitted power.
     * If not defined, average value of received power readings will be used.
     */
    private Double initialTransmittedPowerdBm;

    /**
     * Initial position to start the estimation of radio source position.
     * If not defined, centroid of provided located readings will be used.
     */
    private P initialPosition;

    /**
     * Initial exponent typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     */
<span class="fc" id="L306">    private double initialPathLossExponent = RangingAndRssiRadioSourceEstimator.DEFAULT_PATH_LOSS_EXPONENT;</span>

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     */
<span class="fc" id="L311">    private boolean transmittedPowerEstimationEnabled =</span>
            RangingAndRssiRadioSourceEstimator.DEFAULT_TRANSMITTED_POWER_ESTIMATION_ENABLED;

    /**
     * Indicates whether path loss estimation is enabled or not.
     */
<span class="fc" id="L317">    private boolean pathLossEstimationEnabled =</span>
            RangingAndRssiRadioSourceEstimator.DEFAULT_PATHLOSS_ESTIMATION_ENABLED;

    /**
     * Estimated transmitted power expressed in dBm's.
     */
    private double estimatedTransmittedPowerdBm;

    /**
     * Estimated exponent typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * If path loss exponent estimation is not enabled, this value will always be equal to
     * {@link RssiRadioSourceEstimator#DEFAULT_PATH_LOSS_EXPONENT}
     */
<span class="fc" id="L336">    private double estimatedPathLossExponent = RangingAndRssiRadioSourceEstimator.DEFAULT_PATH_LOSS_EXPONENT;</span>

    /**
     * Variance of estimated transmitted power.
     * This value will only be available when transmitted power
     * estimation is enabled.
     */
    private Double estimatedTransmittedPowerVariance;

    /**
     * Variance of estimated path loss exponent.
     * This value will only be available when path-loss
     * exponent estimation is enabled.
     */
    private Double estimatedPathLossExponentVariance;

    /**
     * Data related to inliers found after estimation.
     */
    private InliersData inliersData;

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard deviation
     * assuming that both measures are statistically independent.
     */
<span class="fc" id="L362">    private boolean useReadingPositionCovariances = DEFAULT_USE_READING_POSITION_COVARIANCES;</span>

    /**
     * Indicates whether an homogeneous ranging linear solver is used to estimate preliminary positions.
     */
<span class="fc" id="L367">    private boolean useHomogeneousRangingLinearSolver =</span>
            RangingRadioSourceEstimator.DEFAULT_USE_HOMOGENEOUS_LINEAR_SOLVER;

    /**
     * Constructor.
     */
<span class="fc" id="L373">    protected SequentialRobustRangingAndRssiRadioSourceEstimator() {</span>
<span class="fc" id="L374">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings signal readings belonging to the same radio source.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
<span class="fc" id="L384">            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings) {</span>
<span class="fc" id="L385">        internalSetReadings(readings);</span>
<span class="fc" id="L386">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener in charge of attending events raised by this instance.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
<span class="fc" id="L394">            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {</span>
<span class="fc" id="L395">        this.listener = listener;</span>
<span class="fc" id="L396">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings signal readings belonging to the same radio source.
     * @param listener listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L409">        this(readings);</span>
<span class="fc" id="L410">        this.listener = listener;</span>
<span class="fc" id="L411">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings        signal readings belonging to the same radio source.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final P initialPosition) {
<span class="fc" id="L424">        this(readings);</span>
<span class="fc" id="L425">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L426">    }</span>

    /**
     * Constructor.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     */
<span class="fc" id="L434">    protected SequentialRobustRangingAndRssiRadioSourceEstimator(final P initialPosition) {</span>
<span class="fc" id="L435">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L436">    }</span>

    /**
     * Constructor.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @param listener        listener in charge of attending events raised by this instance.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final P initialPosition, final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L447">        this(listener);</span>
<span class="fc" id="L448">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L449">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings        signal readings belonging to the same radio source.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @param listener        listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final P initialPosition,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L464">        this(readings, listener);</span>
<span class="fc" id="L465">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L466">    }</span>

    /**
     * Constructor.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     */
<span class="fc" id="L475">    protected SequentialRobustRangingAndRssiRadioSourceEstimator(final Double initialTransmittedPowerdBm) {</span>
<span class="fc" id="L476">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L477">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final Double initialTransmittedPowerdBm) {
<span class="fc" id="L492">        this(readings);</span>
<span class="fc" id="L493">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L494">    }</span>

    /**
     * Constructor.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   listener in charge of attending events raised by this instance.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L507">        this(listener);</span>
<span class="fc" id="L508">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L509">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L525">        this(readings, listener);</span>
<span class="fc" id="L526">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L527">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final P initialPosition,
            final Double initialTransmittedPowerdBm) {
<span class="fc" id="L544">        this(readings);</span>
<span class="fc" id="L545">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L546">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L547">    }</span>

    /**
     * Constructor.
     *
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
<span class="fc" id="L559">            final P initialPosition, final Double initialTransmittedPowerdBm) {</span>
<span class="fc" id="L560">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L561">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L562">    }</span>

    /**
     * Constructor.
     *
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   in charge of attending events raised by this instance.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final P initialPosition, final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L577">        this(listener);</span>
<span class="fc" id="L578">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L579">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L580">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final P initialPosition,
            final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L599">        this(readings, listener);</span>
<span class="fc" id="L600">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L601">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L602">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final P initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent) {
<span class="fc" id="L620">        this(readings, initialPosition, initialTransmittedPowerdBm);</span>
<span class="fc" id="L621">        this.initialPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L622">    }</span>

    /**
     * Constructor.
     *
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final P initialPosition, final Double initialTransmittedPowerdBm, final double initialPathLossExponent) {
<span class="fc" id="L636">        this(initialPosition, initialTransmittedPowerdBm);</span>
<span class="fc" id="L637">        this.initialPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L638">    }</span>

    /**
     * Constructor.
     *
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @param listener                   listener in charge of attending events raised by this instance.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final P initialPosition, final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L654">        this(initialPosition, initialTransmittedPowerdBm, listener);</span>
<span class="fc" id="L655">        this.initialPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L656">    }</span>

    /**
     * Constructors.
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings, final P initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L676">        this(readings, initialPosition, initialTransmittedPowerdBm, listener);</span>
<span class="fc" id="L677">        this.initialPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L678">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores quality scores corresponding to each provided sample.
     *                      The larger the score value the better the quality of
     *                      the sample.
     * @throws IllegalArgumentException if quality scores is null, or length of
     *                                  quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(final double[] qualityScores) {
<span class="fc" id="L690">        this();</span>
<span class="fc" id="L691">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L692">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores quality scores corresponding to each provided sample.
     *                      The larger the score value the better the quality of
     *                      the sample.
     * @param readings      signal readings belonging to the same radio source.
     * @throws IllegalArgumentException if readings are not valid, quality scores is
     *                                  null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings) {
<span class="fc" id="L707">        this(readings);</span>
<span class="fc" id="L708">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L709">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores quality scores corresponding to each provided sample.
     *                      The larger the score value the better the quality of
     *                      the sample.
     * @param listener      listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L724">        this(listener);</span>
<span class="fc" id="L725">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L726">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores quality scores corresponding to each provided sample.
     *                      The larger the score value the better the quality of
     *                      the sample.
     * @param readings      signal readings belonging to the same radio source.
     * @param listener      listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid, quality scores is
     *                                  null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L743">        this(readings, listener);</span>
<span class="fc" id="L744">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L745">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores   quality scores corresponding to each provided sample.
     *                        The larger the score value the better the quality of
     *                        the sample.
     * @param readings        signal readings belonging to the same radio source.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws IllegalArgumentException if readings are not valid, quality scores is
     *                                  null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final P initialPosition) {
<span class="fc" id="L763">        this(readings, initialPosition);</span>
<span class="fc" id="L764">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L765">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores   quality scores corresponding to each provided sample.
     *                        The larger the score value the better the quality of
     *                        the sample.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final P initialPosition) {
<span class="fc" id="L780">        this(initialPosition);</span>
<span class="fc" id="L781">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L782">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores   quality scores corresponding to each provided sample.
     *                        The larger the score value the better the quality of
     *                        the sample.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @param listener        listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final P initialPosition,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L799">        this(initialPosition, listener);</span>
<span class="fc" id="L800">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L801">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores   quality scores corresponding to each provided sample.
     *                        The larger the score value the better the quality of
     *                        the sample.
     * @param readings        signal readings belonging to the same radio source.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @param listener        listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final P initialPosition, final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L820">        this(readings, initialPosition, listener);</span>
<span class="fc" id="L821">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L822">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores              quality scores corresponding to each provided sample.
     *                                   The larger the score value the better the quality of
     *                                   the sample.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final Double initialTransmittedPowerdBm) {
<span class="fc" id="L838">        this(initialTransmittedPowerdBm);</span>
<span class="fc" id="L839">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L840">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores              quality scores corresponding to each provided sample.
     *                                   The larger the score value the better the quality of
     *                                   the sample.
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final Double initialTransmittedPowerdBm) {
<span class="fc" id="L859">        this(readings, initialTransmittedPowerdBm);</span>
<span class="fc" id="L860">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L861">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores              quality scores corresponding to each provided sample.
     *                                   The larger the score value the better the quality of
     *                                   the sample.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L879">        this(initialTransmittedPowerdBm, listener);</span>
<span class="fc" id="L880">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L881">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L902">        this(readings, initialTransmittedPowerdBm, listener);</span>
<span class="fc" id="L903">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L904">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final P initialPosition, final Double initialTransmittedPowerdBm) {
<span class="fc" id="L925">        this(readings, initialPosition, initialTransmittedPowerdBm);</span>
<span class="fc" id="L926">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L927">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final P initialPosition, final Double initialTransmittedPowerdBm) {
<span class="fc" id="L945">        this(initialPosition, initialTransmittedPowerdBm);</span>
<span class="fc" id="L946">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L947">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final P initialPosition, final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L967">        this(initialPosition, initialTransmittedPowerdBm, listener);</span>
<span class="fc" id="L968">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L969">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final P initialPosition, final Double initialTransmittedPowerdBm,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L992">        this(readings, initialPosition, initialTransmittedPowerdBm, listener);</span>
<span class="fc" id="L993">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L994">    }</span>

    /**
     * Constructor.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final P initialPosition, final Double initialTransmittedPowerdBm, final double initialPathLossExponent) {
<span class="fc" id="L1016">        this(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent);</span>
<span class="fc" id="L1017">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L1018">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final P initialPosition, final Double initialTransmittedPowerdBm,
            final double initialPathLossExponent) {
<span class="fc" id="L1038">        this(initialPosition, initialTransmittedPowerdBm, initialPathLossExponent);</span>
<span class="fc" id="L1039">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L1040">    }</span>

    /**
     * Constructor.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if quality scores is null, or length
     *                                  of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final P initialPosition, final Double initialTransmittedPowerdBm,
            final double initialPathLossExponent,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L1062">        this(initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);</span>
<span class="fc" id="L1063">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L1064">    }</span>

    /**
     * Constructors.
     * Sets signal readings belonging to the same radio source.
     *
     * @param qualityScores              quality scores corresponding to each provided
     *                                   sample. The larger the score value the better
     *                                   the quality of the sample.
     * @param readings                   signal readings belonging to the same radio source.
     * @param initialPosition            initial position to start the estimation of radio
     *                                   source position.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted power
     *                                   (expressed in dBm's).
     * @param initialPathLossExponent    initial path loss exponent. A typical value is 2.0.
     * @param listener                   listener in charge of attending events raised by this instance.
     * @throws IllegalArgumentException if readings are not valid, quality scores
     *                                  is null, or length of quality scores is less than required minimum.
     */
    protected SequentialRobustRangingAndRssiRadioSourceEstimator(
            final double[] qualityScores, final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings,
            final P initialPosition, final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
<span class="fc" id="L1088">        this(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);</span>
<span class="fc" id="L1089">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L1090">    }</span>

    /**
     * Indicates whether estimator is locked during estimation.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
<span class="fc" id="L1098">        return locked;</span>
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
<span class="fc" id="L1109">        return progressDelta;</span>
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException          if this estimator is locked.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1123">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1125" title="All 4 branches covered.">        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {</span>
<span class="fc" id="L1126">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1128">        this.progressDelta = progressDelta;</span>
<span class="fc" id="L1129">    }</span>

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
<span class="fc" id="L1137">        return rangingRobustMethod;</span>
    }

    /**
     * Sets robust method used for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod robust method used for robust position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingRobustMethod(final RobustEstimatorMethod rangingRobustMethod) throws LockedException {
<span class="fc bfc" id="L1147" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1148">            throw new LockedException();</span>
        }
<span class="fc" id="L1150">        this.rangingRobustMethod = rangingRobustMethod;</span>
<span class="fc" id="L1151">    }</span>

    /**
     * Gets robust method used for path-loss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @return robust method used for path-loss exponent and transmitted power
     * estimation.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
<span class="fc" id="L1161">        return rssiRobustMethod;</span>
    }

    /**
     * Sets robust method used for path-loss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @param rssiRobustMethod robust method used for path-loss exponent and transmitted
     *                         power estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiRobustMethod(final RobustEstimatorMethod rssiRobustMethod) throws LockedException {
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1174">            throw new LockedException();</span>
        }
<span class="fc" id="L1176">        this.rssiRobustMethod = rssiRobustMethod;</span>
<span class="fc" id="L1177">    }</span>

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
<span class="fc" id="L1185">        return rangingPreliminarySubsetSize;</span>
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize size of subsets to be checked during
     *                                     ranging robust estimation.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRangingPreliminarySubsetSize(final int rangingPreliminarySubsetSize) throws LockedException {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1198">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        if (rangingPreliminarySubsetSize &lt; getMinReadings()) {</span>
<span class="fc" id="L1201">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1204">        this.rangingPreliminarySubsetSize = rangingPreliminarySubsetSize;</span>
<span class="fc" id="L1205">    }</span>

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
<span class="fc" id="L1213">        return rssiPreliminarySubsetSize;</span>
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRssiPreliminarySubsetSize(final int rssiPreliminarySubsetSize) throws LockedException {
<span class="fc bfc" id="L1225" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1226">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        if (rssiPreliminarySubsetSize &lt; getMinReadings()) {</span>
<span class="fc" id="L1229">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1232">        this.rssiPreliminarySubsetSize = rssiPreliminarySubsetSize;</span>
<span class="fc" id="L1233">    }</span>

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
<span class="fc" id="L1243">        return rangingThreshold;</span>
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(final Double rangingThreshold) throws LockedException {
<span class="fc bfc" id="L1255" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1256">            throw new LockedException();</span>
        }
<span class="fc" id="L1258">        this.rangingThreshold = rangingThreshold;</span>
<span class="fc" id="L1259">    }</span>

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * path-loss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
<span class="fc" id="L1269">        return rssiThreshold;</span>
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * path-loss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(final Double rssiThreshold) throws LockedException {
<span class="fc bfc" id="L1281" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1282">            throw new LockedException();</span>
        }
<span class="fc" id="L1284">        this.rssiThreshold = rssiThreshold;</span>
<span class="fc" id="L1285">    }</span>

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for robust position estimation. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value
     * between 0.0 and 1.0.
     */
    public double getRangingConfidence() {
<span class="fc" id="L1297">        return rangingConfidence;</span>
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation. The amount of confidence
     * indicates the probability that the estimated result is correct. Usually this
     * value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation
     *                          as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(final double rangingConfidence) throws LockedException {
<span class="fc bfc" id="L1312" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1313">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1315" title="All 4 branches covered.">        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {</span>
<span class="fc" id="L1316">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1318">        this.rangingConfidence = rangingConfidence;</span>
<span class="fc" id="L1319">    }</span>

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for path-loss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust path-loss exponent and transmitted power
     * estimation as a value between 0.0 and 1.0.
     */
    public double getRssiConfidence() {
<span class="fc" id="L1332">        return rssiConfidence;</span>
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for path-loss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct. Usually this value will be close to 10.0, but
     * not exactly 1.0.
     *
     * @param rssiConfidence confidence to be set for robust path-loss exponent and
     *                       transmitted power estimation as a value between 0.0 and
     *                       1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(final double rssiConfidence) throws LockedException {
<span class="fc bfc" id="L1349" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1350">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1352" title="All 4 branches covered.">        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {</span>
<span class="fc" id="L1353">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1355">        this.rssiConfidence = rssiConfidence;</span>
<span class="fc" id="L1356">    }</span>

    /**
     * Returns maximum allowed number of iterations for robust position estimation. If
     * maximum allowed number of iterations is achieved without converging to a result
     * when calling estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
<span class="fc" id="L1366">        return rangingMaxIterations;</span>
    }

    /**
     * Sets maximum allowed number of iterations for robust position estimation. When
     * the maximum number of iterations is exceeded, an approximate result might be
     * available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set
     *                             for position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked.
     */
    public void setRangingMaxIterations(final int rangingMaxIterations) throws LockedException {
<span class="fc bfc" id="L1380" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1381">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        if (rangingMaxIterations &lt; MIN_ITERATIONS) {</span>
<span class="fc" id="L1384">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1386">        this.rangingMaxIterations = rangingMaxIterations;</span>
<span class="fc" id="L1387">    }</span>

    /**
     * Returns maximum allowed number of iterations for robust path-loss exponent and
     * transmitted power estimation. If maximum allowed number of iterations is achieved
     * without converging to a result when calling estimate(), a RobustEstimatorException
     * will be raised.
     *
     * @return maximum allowed number of iterations for path-loss exponent and transmitted
     * power estimation.
     */
    public int getRssiMaxIterations() {
<span class="fc" id="L1399">        return rssiMaxIterations;</span>
    }

    /**
     * Sets maximum allowed number of iterations for robust path-loss exponent and
     * transmitted power estimation. When the maximum number of iterations is exceeded,
     * an approximate result might be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          path-loss exponent and transmitted power estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked.
     */
    public void setRssiMaxIterations(final int rssiMaxIterations) throws LockedException {
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1414">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        if (rssiMaxIterations &lt; MIN_ITERATIONS) {</span>
<span class="fc" id="L1417">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1419">        this.rssiMaxIterations = rssiMaxIterations;</span>
<span class="fc" id="L1420">    }</span>

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
<span class="fc" id="L1429">        return refineResult;</span>
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if estimator is locked.
     */
    public void setResultRefined(final boolean refineResult) throws LockedException {
<span class="fc bfc" id="L1440" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1441">            throw new LockedException();</span>
        }
<span class="fc" id="L1443">        this.refineResult = refineResult;</span>
<span class="fc" id="L1444">    }</span>

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
<span class="fc" id="L1453">        return keepCovariance;</span>
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(final boolean keepCovariance) throws LockedException {
<span class="fc bfc" id="L1465" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1466">            throw new LockedException();</span>
        }
<span class="fc" id="L1468">        this.keepCovariance = keepCovariance;</span>
<span class="fc" id="L1469">    }</span>

    /**
     * Gets signal readings belonging to the same radio source.
     *
     * @return signal readings belonging to the same radio source.
     */
    public List&lt;RangingAndRssiReadingLocated&lt;S, P&gt;&gt; getReadings() {
        //noinspection unchecked
<span class="fc" id="L1478">        return (List&lt;RangingAndRssiReadingLocated&lt;S,P&gt;&gt;) readings;</span>
    }

    /**
     * Sets signal readings belonging to the same radio source.
     *
     * @param readings signal readings belonging to the same
     *                 radio source.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if readings are not valid.
     */
    public void setReadings(final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings) throws LockedException {
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1491">            throw new LockedException();</span>
        }

<span class="fc" id="L1494">        internalSetReadings(readings);</span>
<span class="fc" id="L1495">    }</span>

    /**
     * Gets listener in charge of attending events raised by this instance.
     *
     * @return listener in charge of attending events raised by this instance.
     */
    public SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; getListener() {
<span class="fc" id="L1503">        return listener;</span>
    }

    /**
     * Sets listener in charge of attending events raised by this instance.
     *
     * @param listener listener in charge of attending events raised by this
     *                 instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(final SequentialRobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener)
            throws LockedException {
<span class="fc bfc" id="L1515" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1516">            throw new LockedException();</span>
        }

<span class="fc" id="L1519">        this.listener = listener;</span>
<span class="fc" id="L1520">    }</span>

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    public double[] getQualityScores() {
<span class="fc" id="L1532">        return qualityScores;</span>
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    public void setQualityScores(final double[] qualityScores) throws LockedException {
<span class="fc bfc" id="L1550" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1551">            throw new LockedException();</span>
        }
<span class="fc" id="L1553">        internalSetQualityScores(qualityScores);</span>
<span class="fc" id="L1554">    }</span>

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
<span class="fc" id="L1565">        return initialTransmittedPowerdBm;</span>
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
<span class="fc bfc" id="L1579" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1580">            throw new LockedException();</span>
        }
<span class="fc" id="L1582">        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
<span class="fc" id="L1583">    }</span>

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
<span class="fc bfc" id="L1594" title="All 2 branches covered.">        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;</span>
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
<span class="fc bfc" id="L1608" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1609">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">        if (initialTransmittedPower != null) {</span>
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">            if (initialTransmittedPower &lt; 0.0) {</span>
<span class="nc" id="L1613">                throw new IllegalArgumentException();</span>
            }
<span class="fc" id="L1615">            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);</span>
        } else {
<span class="nc" id="L1617">            initialTransmittedPowerdBm = null;</span>
        }
<span class="fc" id="L1619">    }</span>

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
<span class="fc" id="L1628">        return initialPosition;</span>
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
<span class="fc bfc" id="L1640" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1641">            throw new LockedException();</span>
        }
<span class="fc" id="L1643">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L1644">    }</span>

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
<span class="fc" id="L1664">        return initialPathLossExponent;</span>
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(final double initialPathLossExponent) throws LockedException {
<span class="fc bfc" id="L1686" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1687">            throw new LockedException();</span>
        }
<span class="fc" id="L1689">        this.initialPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L1690">    }</span>

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
<span class="fc" id="L1698">        return transmittedPowerEstimationEnabled;</span>
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(final boolean transmittedPowerEstimationEnabled)
            throws LockedException {
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1711">            throw new LockedException();</span>
        }
<span class="fc" id="L1713">        this.transmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;</span>
<span class="fc" id="L1714">    }</span>

    /**
     * Indicates whether path loss estimation is enabled or not.
     *
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
<span class="fc" id="L1722">        return pathLossEstimationEnabled;</span>
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     *
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(final boolean pathLossEstimationEnabled) throws LockedException {
<span class="fc bfc" id="L1733" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1734">            throw new LockedException();</span>
        }
<span class="fc" id="L1736">        this.pathLossEstimationEnabled = pathLossEstimationEnabled;</span>
<span class="fc" id="L1737">    }</span>

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
<span class="fc" id="L1747">        return useReadingPositionCovariances;</span>
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(final boolean useReadingPositionCovariances) throws LockedException {
<span class="fc bfc" id="L1760" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1761">            throw new LockedException();</span>
        }
<span class="fc" id="L1763">        this.useReadingPositionCovariances = useReadingPositionCovariances;</span>
<span class="fc" id="L1764">    }</span>

    /**
     * Indicates whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @return true if homogeneous ranging linear solver is used, false if an inhomogeneous ranging linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
<span class="fc" id="L1774">        return useHomogeneousRangingLinearSolver;</span>
    }

    /**
     * Specifies whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @param useHomogeneousRangingLinearSolver true if homogeneous ranging linear solver is used, false
     *                                          if an inhomogeneous ranging linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(final boolean useHomogeneousRangingLinearSolver)
            throws LockedException {
<span class="fc bfc" id="L1787" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1788">            throw new LockedException();</span>
        }

<span class="fc" id="L1791">        this.useHomogeneousRangingLinearSolver = useHomogeneousRangingLinearSolver;</span>
<span class="fc" id="L1792">    }</span>

    /**
     * Gets covariance for estimated position and power.
     * Matrix contains information in the following order:
     * Top-left sub-matrix contains covariance of position,
     * then follows transmitted power variance, and finally
     * the last element contains path-loss exponent variance.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return covariance for estimated position and power.
     */
    public Matrix getCovariance() {
<span class="fc" id="L1805">        return covariance;</span>
    }

    /**
     * Gets estimated position covariance.
     * Size of this matrix will depend on the number of dimensions
     * of estimated position (either 2 or 3).
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated position covariance.
     */
    public Matrix getEstimatedPositionCovariance() {
<span class="fc" id="L1817">        return estimatedPositionCovariance;</span>
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public P getEstimatedPosition() {
<span class="fc" id="L1826">        return estimatedPosition;</span>
    }

    /**
     * Indicates whether readings are valid or not.
     * Readings are considered valid when there are enough readings.
     *
     * @param readings readings to be validated.
     * @return true if readings are valid, false otherwise.
     */
    public boolean areValidReadings(final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings) {
<span class="fc bfc" id="L1837" title="All 4 branches covered.">        return readings != null &amp;&amp; readings.size() &gt;= getMinReadings();</span>
    }

    /**
     * Indicates whether this instance is ready to start the estimation.
     *
     * @return true if this instance is ready, false otherwise.
     * @throws LockedException if estimator is locked
     */
    public boolean isReady() throws LockedException {
<span class="fc" id="L1847">        buildRangingEstimatorIfNeeded();</span>
<span class="fc" id="L1848">        setupRangingEstimator();</span>

<span class="fc bfc" id="L1850" title="All 4 branches covered.">        if (transmittedPowerEstimationEnabled || pathLossEstimationEnabled) {</span>
<span class="fc" id="L1851">            buildRssiEstimatorIfNeeded();</span>
<span class="fc" id="L1852">            setupRssiEstimator();</span>
        }

<span class="fc bfc" id="L1855" title="All 6 branches covered.">        return rangingEstimator.isReady() &amp;&amp; ((!transmittedPowerEstimationEnabled &amp;&amp; !pathLossEstimationEnabled)</span>
<span class="pc bpc" id="L1856" title="1 of 2 branches missed.">                || rssiEstimator.isReady());</span>
    }

    /**
     * Gets estimated transmitted power variance.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated transmitted power variance.
     */
    public Double getEstimatedTransmittedPowerVariance() {
<span class="fc" id="L1866">        return estimatedTransmittedPowerVariance;</span>
    }

    /**
     * Gets estimated path loss exponent variance.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated path loss exponent variance.
     */
    public Double getEstimatedPathLossExponentVariance() {
<span class="fc" id="L1876">        return estimatedPathLossExponentVariance;</span>
    }

    /**
     * Gets estimated transmitted power expressed in milli watts (mW).
     *
     * @return estimated transmitted power expressed in milli watts.
     */
    public double getEstimatedTransmittedPower() {
<span class="fc" id="L1885">        return Utils.dBmToPower(estimatedTransmittedPowerdBm);</span>
    }

    /**
     * Gets estimated transmitted power expressed in dBm's.
     *
     * @return estimated transmitted power expressed in dBm's.
     */
    public double getEstimatedTransmittedPowerdBm() {
<span class="fc" id="L1894">        return estimatedTransmittedPowerdBm;</span>
    }

    /**
     * Gets estimated exponent typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * If path loss exponent estimation is not enabled, this value will always be equal to
     * {@link RssiRadioSourceEstimator#DEFAULT_PATH_LOSS_EXPONENT}
     *
     * @return estimated path loss exponent.
     */
    public double getEstimatedPathLossExponent() {
<span class="fc" id="L1911">        return estimatedPathLossExponent;</span>
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
<span class="fc bfc" id="L1924" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1925">            throw new LockedException();</span>
        }
        try {
<span class="fc" id="L1928">            locked = true;</span>

            // when checking for readiness, inner estimators are created and setup
<span class="fc bfc" id="L1931" title="All 2 branches covered.">            if (!isReady()) {</span>
<span class="fc" id="L1932">                throw new NotReadyException();</span>
            }


<span class="fc bfc" id="L1936" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L1937">                listener.onEstimateStart(this);</span>
            }

            // estimate position
<span class="fc" id="L1941">            rangingEstimator.setPreliminarySubsetSize(rangingPreliminarySubsetSize);</span>

<span class="fc" id="L1943">            rangingEstimator.estimate();</span>

<span class="fc" id="L1945">            estimatedPosition = rangingEstimator.getEstimatedPosition();</span>
<span class="fc" id="L1946">            estimatedPositionCovariance = rangingEstimator.getEstimatedPositionCovariance();</span>
<span class="fc" id="L1947">            inliersData = rangingEstimator.getInliersData();</span>

            // estimate transmitted power and/or path-loss if enabled
<span class="fc bfc" id="L1950" title="All 4 branches covered.">            if (transmittedPowerEstimationEnabled || pathLossEstimationEnabled) {</span>
<span class="fc" id="L1951">                rssiEstimator.setPositionEstimationEnabled(false);</span>
<span class="fc" id="L1952">                rssiEstimator.setInitialPosition(estimatedPosition);</span>
<span class="fc" id="L1953">                rssiEstimator.setPreliminarySubsetSize(rssiPreliminarySubsetSize);</span>

<span class="fc" id="L1955">                rssiEstimator.estimate();</span>

<span class="fc bfc" id="L1957" title="All 2 branches covered.">                if (transmittedPowerEstimationEnabled) {</span>
                    // transmitted power estimation enabled
<span class="fc" id="L1959">                    estimatedTransmittedPowerdBm = rssiEstimator.getEstimatedTransmittedPowerdBm();</span>
<span class="fc" id="L1960">                    estimatedTransmittedPowerVariance = rssiEstimator.getEstimatedTransmittedPowerVariance();</span>
                } else {
                    // transmitted power estimation disabled
<span class="pc bpc" id="L1963" title="1 of 2 branches missed.">                    if (initialTransmittedPowerdBm != null) {</span>
<span class="fc" id="L1964">                        estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
                    }
<span class="fc" id="L1966">                    estimatedTransmittedPowerVariance = null;</span>
                }

<span class="fc bfc" id="L1969" title="All 2 branches covered.">                if (pathLossEstimationEnabled) {</span>
                    // path-loss exponent estimation enabled
<span class="fc" id="L1971">                    estimatedPathLossExponent = rssiEstimator.getEstimatedPathLossExponent();</span>
<span class="fc" id="L1972">                    estimatedPathLossExponentVariance = rssiEstimator.getEstimatedPathLossExponentVariance();</span>
                } else {
                    // path-loss exponent estimation disabled
<span class="fc" id="L1975">                    estimatedPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L1976">                    estimatedPathLossExponentVariance = null;</span>
                }

                // build covariance matrix
<span class="fc" id="L1980">                final var rssiCov = rssiEstimator.getCovariance();</span>
<span class="pc bpc" id="L1981" title="1 of 4 branches missed.">                if (estimatedPositionCovariance != null &amp;&amp; rssiCov != null) {</span>
<span class="fc" id="L1982">                    final var dims = getNumberOfDimensions();</span>
<span class="fc" id="L1983">                    var n = dims;</span>
<span class="fc bfc" id="L1984" title="All 2 branches covered.">                    if (transmittedPowerEstimationEnabled) {</span>
<span class="fc" id="L1985">                        n++;</span>
                    }
<span class="fc bfc" id="L1987" title="All 2 branches covered.">                    if (pathLossEstimationEnabled) {</span>
<span class="fc" id="L1988">                        n++;</span>
                    }

<span class="fc" id="L1991">                    final var dimsMinus1 = dims - 1;</span>
<span class="fc" id="L1992">                    final var nMinus1 = n - 1;</span>
<span class="fc" id="L1993">                    covariance = new Matrix(n, n);</span>
<span class="fc" id="L1994">                    covariance.setSubmatrix(0, 0, dimsMinus1, dimsMinus1,</span>
                            estimatedPositionCovariance);
<span class="fc" id="L1996">                    covariance.setSubmatrix(dims, dims, nMinus1, nMinus1, rssiCov);</span>
<span class="fc" id="L1997">                } else {</span>
<span class="fc" id="L1998">                    covariance = null;</span>
                }
<span class="fc" id="L2000">            } else {</span>
<span class="fc" id="L2001">                covariance = estimatedPositionCovariance;</span>
<span class="pc bpc" id="L2002" title="1 of 2 branches missed.">                if (initialTransmittedPowerdBm != null) {</span>
<span class="fc" id="L2003">                    estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;</span>
                }
<span class="fc" id="L2005">                estimatedTransmittedPowerVariance = null;</span>

<span class="fc" id="L2007">                estimatedPathLossExponent = initialPathLossExponent;</span>
<span class="fc" id="L2008">                estimatedPathLossExponentVariance = null;</span>
            }

<span class="fc bfc" id="L2011" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L2012">                listener.onEstimateEnd(this);</span>
            }
<span class="nc" id="L2014">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L2015">            throw new RobustEstimatorException(e);</span>
        } finally {
<span class="fc" id="L2017">            locked = false;</span>
        }
<span class="fc" id="L2019">    }</span>

    /**
     * Gets data related to inliers found after estimation.
     *
     * @return data related to inliers found after estimation.
     */
    public InliersData getInliersData() {
<span class="fc" id="L2027">        return inliersData;</span>
    }

    /**
     * Gets minimum required number of readings to estimate
     * power, position and path-loss exponent.
     * This value depends on the number of parameters to
     * be estimated, but for position only, this is 3
     * readings for 2D, and 4 readings for 3D.
     *
     * @return minimum required number of readings.
     */
    public abstract int getMinReadings();

    /**
     * Gets number of dimensions of position points.
     *
     * @return number of dimensions of position points.
     */
    public abstract int getNumberOfDimensions();

    /**
     * Gets estimated located radio source.
     *
     * @param &lt;S2&gt; type of located radio source.
     * @return estimated located radio source.
     */
    public abstract &lt;S2 extends RadioSourceLocated&lt;P&gt;&gt; S2 getEstimatedRadioSource();

    /**
     * Builds ranging estimator.
     */
    protected abstract void buildRangingEstimatorIfNeeded();

    /**
     * Build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    protected abstract void buildRssiEstimatorIfNeeded() throws LockedException;

    /**
     * Setups ranging estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    protected void setupRangingEstimator() throws LockedException {
<span class="fc bfc" id="L2074" title="All 2 branches covered.">        if (readings != null) {</span>
            //build ranging readings
<span class="fc" id="L2076">            final var rangingReadings = new ArrayList&lt;RangingReadingLocated&lt;S, P&gt;&gt;();</span>
<span class="fc bfc" id="L2077" title="All 2 branches covered.">            for (final var reading : readings) {</span>
<span class="fc" id="L2078">                rangingReadings.add(createRangingReading(reading));</span>
<span class="fc" id="L2079">            }</span>
<span class="fc" id="L2080">            rangingEstimator.setReadings(rangingReadings);</span>
        }

<span class="fc bfc" id="L2083" title="All 2 branches covered.">        if (qualityScores != null) {</span>
<span class="fc" id="L2084">            rangingEstimator.setQualityScores(qualityScores);</span>
        }

<span class="fc" id="L2087">        rangingEstimator.setProgressDelta(2.0f * progressDelta);</span>
<span class="fc" id="L2088">        rangingEstimator.setConfidence(rangingConfidence);</span>
<span class="fc" id="L2089">        rangingEstimator.setMaxIterations(rangingMaxIterations);</span>
<span class="fc" id="L2090">        rangingEstimator.setResultRefined(refineResult);</span>
<span class="fc" id="L2091">        rangingEstimator.setCovarianceKept(keepCovariance);</span>
<span class="fc" id="L2092">        rangingEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);</span>
<span class="fc" id="L2093">        rangingEstimator.setHomogeneousLinearSolverUsed(useHomogeneousRangingLinearSolver);</span>

<span class="fc" id="L2095">        rangingEstimator.setInitialPosition(initialPosition);</span>

<span class="fc" id="L2097">        rangingEstimator.setListener(new RobustRangingRadioSourceEstimatorListener&lt;&gt;() {</span>
            @Override
            public void onEstimateStart(final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
<span class="fc" id="L2101">            }</span>

            @Override
            public void onEstimateEnd(final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
<span class="fc" id="L2106">            }</span>

            @Override
            public void onEstimateNextIteration(
                    final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator, final int iteration) {
                // not used
<span class="fc" id="L2112">            }</span>

            @Override
            public void onEstimateProgressChange(
                    final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator, final float progress) {
<span class="nc bnc" id="L2117" title="All 2 branches missed.">                if (listener != null) {</span>
<span class="nc" id="L2118">                    listener.onEstimateProgressChange(</span>
                            SequentialRobustRangingAndRssiRadioSourceEstimator.this, 0.5f * progress);
                }
<span class="nc" id="L2121">            }</span>
        });
<span class="fc" id="L2123">    }</span>

    /**
     * Setups RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    protected void setupRssiEstimator() throws LockedException {
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        if (readings != null) {</span>
            // build RSSI readings
<span class="fc" id="L2133">            final var rssiReadings = new ArrayList&lt;RssiReadingLocated&lt;S, P&gt;&gt;();</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">            for (final var reading : readings) {</span>
<span class="fc" id="L2135">                rssiReadings.add(createRssiReading(reading));</span>
<span class="fc" id="L2136">            }</span>
<span class="fc" id="L2137">            rssiEstimator.setReadings(rssiReadings);</span>
        }

<span class="fc bfc" id="L2140" title="All 2 branches covered.">        if (qualityScores != null) {</span>
<span class="fc" id="L2141">            rssiEstimator.setQualityScores(qualityScores);</span>
        }

<span class="fc" id="L2144">        rssiEstimator.setProgressDelta(2.0f * progressDelta);</span>
<span class="fc" id="L2145">        rssiEstimator.setConfidence(rssiConfidence);</span>
<span class="fc" id="L2146">        rssiEstimator.setMaxIterations(rssiMaxIterations);</span>
<span class="fc" id="L2147">        rssiEstimator.setResultRefined(refineResult);</span>
<span class="fc" id="L2148">        rssiEstimator.setCovarianceKept(keepCovariance);</span>

        // initial position is not set because position estimated from ranging measures
        // will be later used
<span class="fc" id="L2152">        rssiEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);</span>
<span class="fc" id="L2153">        rssiEstimator.setInitialPathLossExponent(initialPathLossExponent);</span>

<span class="fc" id="L2155">        rssiEstimator.setTransmittedPowerEstimationEnabled(</span>
                transmittedPowerEstimationEnabled);
<span class="fc" id="L2157">        rssiEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);</span>

<span class="fc" id="L2159">        rssiEstimator.setListener(new RobustRssiRadioSourceEstimatorListener&lt;&gt;() {</span>
            @Override
            public void onEstimateStart(final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
<span class="fc" id="L2163">            }</span>

            @Override
            public void onEstimateEnd(final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
<span class="fc" id="L2168">            }</span>

            @Override
            public void onEstimateNextIteration(
                    final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator, final int iteration) {
                // not used
<span class="fc" id="L2174">            }</span>

            @Override
            public void onEstimateProgressChange(
                    final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator, final float progress) {
<span class="nc bnc" id="L2179" title="All 2 branches missed.">                if (listener != null) {</span>
<span class="nc" id="L2180">                    listener.onEstimateProgressChange(</span>
                            SequentialRobustRangingAndRssiRadioSourceEstimator.this,
                            0.5f + 0.5f * progress);
                }
<span class="nc" id="L2184">            }</span>
        });
<span class="fc" id="L2186">    }</span>

    /**
     * Internally sets signal readings belonging to the same radio source.
     *
     * @param readings signal readings belonging to the same radio source.
     * @throws IllegalArgumentException if readings are null, not enough readings
     *                                  are available, or readings do not belong to the same access point.
     */
    private void internalSetReadings(final List&lt;? extends RangingAndRssiReadingLocated&lt;S, P&gt;&gt; readings) {
<span class="fc bfc" id="L2196" title="All 2 branches covered.">        if (!areValidReadings(readings)) {</span>
<span class="fc" id="L2197">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2200">        this.readings = readings;</span>
<span class="fc" id="L2201">    }</span>

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than required minimum.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
<span class="fc bfc" id="L2213" title="All 4 branches covered.">        if (qualityScores == null || qualityScores.length &lt; getMinReadings()) {</span>
<span class="fc" id="L2214">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2217">        this.qualityScores = qualityScores;</span>
<span class="fc" id="L2218">    }</span>

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
<span class="fc" id="L2227">        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),</span>
<span class="fc" id="L2228">                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());</span>
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
<span class="fc" id="L2238">        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),</span>
<span class="fc" id="L2239">                reading.getRssiStandardDeviation(), reading.getPositionCovariance());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>