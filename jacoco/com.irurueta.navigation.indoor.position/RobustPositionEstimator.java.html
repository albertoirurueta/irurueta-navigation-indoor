<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RobustPositionEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-indoor</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.position</a> &gt; <span class="el_source">RobustPositionEstimator.java</span></div><h1>RobustPositionEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.position;

import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.Fingerprint;
import com.irurueta.navigation.indoor.RadioSource;
import com.irurueta.navigation.indoor.RadioSourceLocated;
import com.irurueta.navigation.indoor.Reading;
import com.irurueta.navigation.lateration.NonLinearLeastSquaresLaterationSolver;
import com.irurueta.navigation.lateration.RobustLaterationSolver;
import com.irurueta.navigation.lateration.RobustLaterationSolverListener;
import com.irurueta.numerical.robust.InliersData;
import com.irurueta.numerical.robust.RobustEstimatorException;
import com.irurueta.numerical.robust.RobustEstimatorMethod;

import java.util.ArrayList;
import java.util.List;

/**
 * Base class for robust position estimators using located radio sources and their
 * readings at unknown locations.
 * These kind of estimators can be used to robustly determine the position of a given
 * device by getting readings at an unknown location of different radio sources whose
 * locations are known.
 * Implementations of this class should be able to detect and discard outliers in order
 * to find the best solution.
 *
 * @param &lt;P&gt; a {@link Point} type.
 * @param &lt;R&gt; a {@link Reading} type.
 * @param &lt;L&gt; a {@link RobustPositionEstimatorListener} type.
 */
public abstract class RobustPositionEstimator&lt;P extends Point&lt;?&gt;,
        R extends Reading&lt;? extends RadioSource&gt;,
        L extends RobustPositionEstimatorListener&lt;? extends RobustPositionEstimator&lt;?, ?, ?&gt;&gt;&gt; {

    /**
     * Default robust estimator method when none is provided.
     */
<span class="fc" id="L56">    public static final RobustEstimatorMethod DEFAULT_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;</span>

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation.
     */
    public static final boolean DEFAULT_USE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_READINGS = true;

    /**
     * Distance standard deviation assumed for provided distances as a fallback when
     * none can be determined.
     */
    public static final double FALLBACK_DISTANCE_STANDARD_DEVIATION =
            NonLinearLeastSquaresLaterationSolver.DEFAULT_DISTANCE_STANDARD_DEVIATION;

    /**
     * Located radio sources  used for lateration.
     */
    protected List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources;

    /**
     * Fingerprint containing readings at an unknown location for provided located
     * radio sources.
     */
    protected Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint;

    /**
     * Indicates whether located radio source position covariances must be taken into
     * account (if available) to determine distance standard deviation.
     */
<span class="fc" id="L92">    private boolean useRadioSourcePositionCovariance = DEFAULT_USE_RADIO_SOURCE_POSITION_COVARIANCE;</span>

    /**
     * Indicates whether readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and readings.
     */
<span class="fc" id="L98">    private boolean evenlyDistributeReadings = DEFAULT_EVENLY_DISTRIBUTE_READINGS;</span>

    /**
     * Distance standard deviation fallback value to use when none can be determined
     * from provided radio sources and fingerprint readings.
     */
<span class="fc" id="L104">    private double fallbackDistanceStandardDeviation = FALLBACK_DISTANCE_STANDARD_DEVIATION;</span>

    /**
     * Listener to be notified of events raised by this instance.
     */
    protected L listener;

    /**
     * A robust lateration solver to solve position.
     */
    protected RobustLaterationSolver&lt;P&gt; laterationSolver;

    /**
     * Listener for the robust lateration solver.
     */
    protected RobustLaterationSolverListener&lt;P&gt; trilaterationSolverListener;

    /**
     * Size of subsets to be checked during robust estimation.
     */
    protected int preliminarySubsetSize;

    /**
     * Constructor.
     */
<span class="fc" id="L129">    protected RobustPositionEstimator() {</span>
<span class="fc" id="L130">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener in charge of handling events.
     */
<span class="fc" id="L137">    protected RobustPositionEstimator(final L listener) {</span>
<span class="fc" id="L138">        this.listener = listener;</span>
<span class="fc" id="L139">    }</span>

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;RadioSourceLocated&lt;P&gt;&gt; getSources() {
        //noinspection unchecked
<span class="fc" id="L148">        return (List&lt;RadioSourceLocated&lt;P&gt;&gt;) sources;</span>
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    public void setSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) throws LockedException {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L162">            throw new LockedException();</span>
        }

<span class="fc" id="L165">        internalSetSources(sources);</span>
<span class="fc" id="L166">    }</span>

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt; getFingerprint() {
        //noinspection unchecked
<span class="fc" id="L177">        return (Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt;) fingerprint;</span>
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprint(
            final Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint) throws LockedException {
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L191">            throw new LockedException();</span>
        }

<span class="fc" id="L194">        internalSetFingerprint(fingerprint);</span>
<span class="fc" id="L195">    }</span>

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
<span class="fc" id="L203">        return listener;</span>
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     *
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L214">            throw new LockedException();</span>
        }
<span class="fc" id="L216">        this.listener = listener;</span>
<span class="fc" id="L217">    }</span>

    /**
     * Indicates whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @return true to take radio source position covariance into account, false
     * otherwise.
     */
    public boolean isRadioSourcePositionCovarianceUsed() {
<span class="fc" id="L227">        return useRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @param useRadioSourcePositionCovariance true to take radio source position
     *                                         covariance into account, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovarianceUsed(
            final boolean useRadioSourcePositionCovariance) throws LockedException {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L241">            throw new LockedException();</span>
        }
<span class="fc" id="L243">        this.useRadioSourcePositionCovariance = useRadioSourcePositionCovariance;</span>

<span class="fc" id="L245">        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();</span>
<span class="fc" id="L246">    }</span>

    /**
     * Indicates whether readings are evenly distributed among radio sources taking
     * into account quality scores of both radio sources and readings.
     *
     * @return true if readings are evenly distributed, false otherwise.
     */
    public boolean getEvenlyDistributeReadings() {
<span class="fc" id="L255">        return evenlyDistributeReadings;</span>
    }

    /**
     * Specifies whether readings are evenly distributed among radio sources taking
     * into account quality scores of both radio sources and readings.
     *
     * @param evenlyDistributeReadings true if readings are evenly distributed, false
     *                                 otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setEvenlyDistributeReadings(final boolean evenlyDistributeReadings) throws LockedException {
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L268">            throw new LockedException();</span>
        }
<span class="fc" id="L270">        this.evenlyDistributeReadings = evenlyDistributeReadings;</span>

<span class="fc" id="L272">        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();</span>
<span class="fc" id="L273">    }</span>

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @return distance standard deviation to use as fallback.
     */
    public double getFallbackDistanceStandardDeviation() {
<span class="fc" id="L282">        return fallbackDistanceStandardDeviation;</span>
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @param fallbackDistanceStandardDeviation distance standard deviation to use
     *                                          as fallback.
     * @throws LockedException if estimator is locked.
     */
    public void setFallbackDistanceStandardDeviation(final double fallbackDistanceStandardDeviation)
            throws LockedException {
<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L296">            throw new LockedException();</span>
        }
<span class="fc" id="L298">        this.fallbackDistanceStandardDeviation = fallbackDistanceStandardDeviation;</span>

<span class="fc" id="L300">        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();</span>
<span class="fc" id="L301">    }</span>

    /**
     * Returns boolean indicating if estimator is locked because estimation is
     * under progress.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
<span class="fc" id="L310">        return laterationSolver.isLocked();</span>
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
<span class="fc" id="L321">        return laterationSolver.getProgressDelta();</span>
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if progress delta is less than zero or greater
     *                                  than 1.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
<span class="fc" id="L335">        laterationSolver.setProgressDelta(progressDelta);</span>
<span class="fc" id="L336">    }</span>

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%). The amount of confidence indicates the probability that the
     * estimated result is correct. Usually this value will be close to 1.0, but not
     * exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
<span class="fc" id="L347">        return laterationSolver.getConfidence();</span>
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%). The amount of confidence indicates the probability that the
     * estimated result is correct. Usually this value will be close to 1.0, but not
     * exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     */
    public void setConfidence(final double confidence) throws LockedException {
<span class="fc" id="L361">        laterationSolver.setConfidence(confidence);</span>
<span class="fc" id="L362">    }</span>

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number of
     * iterations is achieved without converging to a result when calling solve(),
     * a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
<span class="fc" id="L372">        return laterationSolver.getMaxIterations();</span>
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of iterations
     * is exceeded, result will not be available, however an approximate result will be
     * available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is less than 1.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
<span class="fc" id="L385">        laterationSolver.setMaxIterations(maxIterations);</span>
<span class="fc" id="L386">    }</span>

    /**
     * Indicates whether result must be refined using a non-linear estimator over found
     * inliers.
     *
     * @return true to refine result, false to simply use result found by robust
     * estimator without further refining.
     */
    public boolean isResultRefined() {
<span class="fc" id="L396">        return laterationSolver.isResultRefined();</span>
    }

    /**
     * Specifies whether result must be refined using a non-linear estimator over found
     * inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by
     *                     robust estimator without further refining.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(final boolean refineResult) throws LockedException {
<span class="fc" id="L408">        laterationSolver.setResultRefined(refineResult);</span>
<span class="fc" id="L409">    }</span>

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
<span class="fc" id="L418">        return laterationSolver.isCovarianceKept();</span>
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setCovarianceKept(final boolean keepCovariance) throws LockedException {
<span class="fc" id="L430">        laterationSolver.setCovarianceKept(keepCovariance);</span>
<span class="fc" id="L431">    }</span>

    /**
     * Gets initial position to use as a starting point to find a new solution.
     * This is optional, but if provided, when no linear solvers are used, this is
     * taken into account. If linear solvers are used, this is ignored.
     *
     * @return an initial position.
     */
    public P getInitialPosition() {
<span class="fc" id="L441">        return laterationSolver.getInitialPosition();</span>
    }

    /**
     * Sets initial position to use as a starting point to find a new solution.
     * This is optional, but if provided, when no linear solvers are used, this is
     * taken into account. If linear solvers are used, this is ignored.
     *
     * @param initialPosition an initial position.
     * @throws LockedException if this instance is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
<span class="fc" id="L453">        laterationSolver.setInitialPosition(initialPosition);</span>
<span class="fc" id="L454">    }</span>

    /**
     * Indicates whether a linear solver is used or not (either homogeneous or
     * inhomogeneous) for preliminary solutions.
     *
     * @return true if a linear solver is used, false otherwise.
     */
    public boolean isLinearSolverUsed() {
<span class="fc" id="L463">        return laterationSolver.isLinearSolverUsed();</span>
    }

    /**
     * Specifies whether a linear solver is used or not (either homogeneous or
     * inhomogeneous) for preliminary solutions.
     *
     * @param linearSolverUsed true if a linear solver is used, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setLinearSolverUsed(final boolean linearSolverUsed) throws LockedException {
<span class="fc" id="L474">        laterationSolver.setLinearSolverUsed(linearSolverUsed);</span>
<span class="fc" id="L475">    }</span>

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that will
     * be later refined.
     *
     * @return true if homogeneous linear solver is used, false otherwise.
     */
    public boolean isHomogeneousLinearSolverUsed() {
<span class="fc" id="L485">        return laterationSolver.isHomogeneousLinearSolverUsed();</span>
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that will
     * be later refined.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used,
     *                                   false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousLinearSolverUsed(final boolean useHomogeneousLinearSolver) throws LockedException {
<span class="fc" id="L498">        laterationSolver.setHomogeneousLinearSolverUsed(useHomogeneousLinearSolver);</span>
<span class="fc" id="L499">    }</span>

    /**
     * Indicates whether preliminary solutions must be refined after an initial linear
     * solution is found.
     * If no initial solution is found using a linear solver, a non-linear solver will
     * be used regardless of this value using an average solution as the initial value
     * to be refined.
     *
     * @return true if preliminary solutions must be refined after an initial linear
     * solution, false otherwise.
     */
    public boolean isPreliminarySolutionRefined() {
<span class="fc" id="L512">        return laterationSolver.isPreliminarySolutionRefined();</span>
    }

    /**
     * Specifies whether preliminary solutions must be refined after an initial linear
     * solution is found.
     * If no initial solution is found using a linear solver, a non-linear solver will
     * be used regardless of this value using an average solution as the initial value
     * to be refined.
     *
     * @param preliminarySolutionRefined true if preliminary solutions must be refined
     *                                   after an initial linear solution, false
     *                                   otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPreliminarySolutionRefined(final boolean preliminarySolutionRefined) throws LockedException {
<span class="fc" id="L528">        laterationSolver.setPreliminarySolutionRefined(preliminarySolutionRefined);</span>
<span class="fc" id="L529">    }</span>

    /**
     * Gets data related to inliers found after estimation.
     * Inlier data is related to the internal positions and distances used for
     * solving lateration.
     *
     * @return data related to inliers found after estimation.
     */
    public InliersData getInliersData() {
<span class="fc" id="L539">        return laterationSolver.getInliersData();</span>
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    public P[] getPositions() {
<span class="fc" id="L548">        return laterationSolver.getPositions();</span>
    }

    /**
     * Gets Euclidean distances from known located radio sources to the location of
     * provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return Euclidean distances used internally.
     */
    public double[] getDistances() {
<span class="fc" id="L559">        return laterationSolver.getDistances();</span>
    }

    /**
     * Gets standard deviation distances from known located radio sources to the
     * location of provided readings in a fingerprint.
     * Distance standard deviations are used internally to solve lateration.
     *
     * @return standard deviations used internally.
     */
    public double[] getDistanceStandardDeviations() {
<span class="fc" id="L570">        return laterationSolver.getDistanceStandardDeviations();</span>
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc" id="L579">        return laterationSolver.isReady();</span>
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
<span class="fc" id="L591">        return null;</span>
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
<span class="fc" id="L606">    }</span>

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
<span class="fc" id="L618">        return null;</span>
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
<span class="fc" id="L635">    }</span>

    /**
     * Gets size of subsets to be checked during robust estimation.
     * This has to be at least {@link #getMinRequiredSources()}.
     *
     * @return size of subsets to be checked during robust estimation.
     */
    public int getPreliminarySubsetSize() {
<span class="fc" id="L644">        return preliminarySubsetSize;</span>
    }

    /**
     * Sets size of subsets to be checked during robust estimation.
     * This has to be at least {@link #getMinRequiredSources()}.
     *
     * @param preliminarySubsetSize size of subsets to be checked during robust estimation.
     * @throws LockedException          if instance is busy solving the lateration problem.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setPreliminarySubsetSize(final int preliminarySubsetSize) throws LockedException {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L657">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (preliminarySubsetSize &lt; getMinRequiredSources()) {</span>
<span class="fc" id="L660">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L663">        this.preliminarySubsetSize = preliminarySubsetSize;</span>

<span class="fc" id="L665">        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();</span>
<span class="fc" id="L666">    }</span>

    /**
     * Gets estimated covariance of estimated position if available.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated covariance or null.
     */
    public Matrix getCovariance() {
<span class="fc" id="L675">        return laterationSolver.getCovariance();</span>
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public P getEstimatedPosition() {
<span class="fc" id="L684">        return laterationSolver.getEstimatedPosition();</span>
    }

    /**
     * Gets number of dimensions of provided points.
     *
     * @return number of dimensions of provided points.
     */
    public int getNumberOfDimensions() {
<span class="fc" id="L693">        return laterationSolver.getNumberOfDimensions();</span>
    }

    /**
     * Estimates position based on provided located radio sources and readings of such
     * sources at an unknown location.
     *
     * @return estimated position.
     * @throws LockedException          if estimator is locked.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for some other reason.
     */
    public P estimate() throws LockedException, NotReadyException, RobustEstimatorException {
<span class="fc" id="L706">        laterationSolver.setPreliminarySubsetSize(preliminarySubsetSize);</span>
<span class="fc" id="L707">        return laterationSolver.solve();</span>
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform
     * lateration.
     */
    public abstract int getMinRequiredSources();

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    public abstract RobustEstimatorMethod getMethod();

    /**
     * Internally sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required minimum.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void internalSetSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
<span class="fc bfc" id="L734" title="All 2 branches covered.">        if (sources == null) {</span>
<span class="fc" id="L735">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (sources.size() &lt; getMinRequiredSources()) {</span>
<span class="fc" id="L739">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L742">        this.sources = sources;</span>

<span class="fc" id="L744">        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();</span>
<span class="fc" id="L745">    }</span>

    /**
     * Internally sets fingerprint containing readings at an unknown location for
     * provided located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    protected void internalSetFingerprint(final Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint) {
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (fingerprint == null) {</span>
<span class="fc" id="L757">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L760">        this.fingerprint = fingerprint;</span>

<span class="fc" id="L762">        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();</span>
<span class="fc" id="L763">    }</span>

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     * @param distanceQualityScores      distance quality scores or null if not required.
     */
    protected abstract void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            final List&lt;P&gt; positions, List&lt;Double&gt; distances, final List&lt;Double&gt; distanceStandardDeviations,
            final List&lt;Double&gt; distanceQualityScores);

    /**
     * Builds positions, distances, standard deviation of distances and quality scores
     * for the internal lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void buildPositionsDistancesDistanceStandardDeviationsAndQualityScores() {
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        if (laterationSolver == null) {</span>
<span class="nc" id="L785">            return;</span>
        }

<span class="fc" id="L788">        final var min = getPreliminarySubsetSize();</span>
<span class="pc bpc" id="L789" title="2 of 8 branches missed.">        if (sources == null || fingerprint == null || sources.size() &lt; min || fingerprint.getReadings() == null</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                || fingerprint.getReadings().size() &lt; min) {</span>
<span class="fc" id="L791">            return;</span>
        }

<span class="fc" id="L794">        final var positions = new ArrayList&lt;P&gt;();</span>
<span class="fc" id="L795">        final var distances = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L796">        final var distanceStandardDeviations = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L798">        var sourceQualityScores = getSourceQualityScores();</span>
<span class="fc" id="L799">        var fingerprintReadingsQualityScores = getFingerprintReadingsQualityScores();</span>

<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        if (evenlyDistributeReadings) {</span>
            // distribute evenly by modifying the relative values of quality scores
<span class="fc bfc" id="L803" title="All 2 branches covered.">            if (sourceQualityScores == null) {</span>
<span class="fc" id="L804">                sourceQualityScores = new double[sources.size()];</span>
            }
<span class="fc bfc" id="L806" title="All 2 branches covered.">            if (fingerprintReadingsQualityScores == null) {</span>
<span class="fc" id="L807">                fingerprintReadingsQualityScores = new double[fingerprint.getReadings().size()];</span>
            }

<span class="fc" id="L810">            final var sorter = new ReadingSorter&lt;P, R&gt;(sources, fingerprint, sourceQualityScores,</span>
                    fingerprintReadingsQualityScores);
<span class="fc" id="L812">            sorter.sort();</span>

<span class="fc" id="L814">            final var sortedSources = sorter.getSortedSourcesAndReadings();</span>

<span class="fc" id="L816">            var j = 0;</span>
<span class="fc" id="L817">            var k = 0;</span>
            boolean finished;
            do {
<span class="fc" id="L820">                var i = 0;</span>
<span class="fc" id="L821">                finished = true;</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">                for (final var sortedSource : sortedSources) {</span>
<span class="fc" id="L823">                    sourceQualityScores[sortedSource.position] = i;</span>
<span class="fc" id="L824">                    i--;</span>

<span class="fc" id="L826">                    final var sortedReadings = sortedSource.readingsWithQualityScores;</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                    if (k &lt; sortedReadings.size()) {</span>
<span class="nc" id="L828">                        finished = false;</span>
<span class="nc" id="L829">                        ReadingSorter.ReadingWithQualityScore&lt;R&gt; sortedReading = sortedReadings.get(k);</span>

<span class="nc" id="L831">                        fingerprintReadingsQualityScores[sortedReading.position] = j;</span>
<span class="nc" id="L832">                        j--;</span>
                    }
<span class="fc" id="L834">                }</span>
<span class="fc" id="L835">                k++;</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            } while (!finished);</span>
        }

<span class="fc" id="L839">        List&lt;Double&gt; distanceQualityScores = null;</span>
<span class="pc bpc" id="L840" title="3 of 4 branches missed.">        if (sourceQualityScores != null || fingerprintReadingsQualityScores != null) {</span>
<span class="fc" id="L841">            distanceQualityScores = new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L843">        PositionEstimatorHelper.buildPositionsDistancesDistanceStandardDeviationsAndQualityScores(</span>
                sources, fingerprint, sourceQualityScores, fingerprintReadingsQualityScores,
<span class="fc" id="L845">                isRadioSourcePositionCovarianceUsed(), getFallbackDistanceStandardDeviation(), positions, distances,</span>
                distanceStandardDeviations, distanceQualityScores);

<span class="fc" id="L848">        setPositionsDistancesDistanceStandardDeviationsAndQualityScores(positions, distances,</span>
                distanceStandardDeviations, distanceQualityScores);
<span class="fc" id="L850">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>