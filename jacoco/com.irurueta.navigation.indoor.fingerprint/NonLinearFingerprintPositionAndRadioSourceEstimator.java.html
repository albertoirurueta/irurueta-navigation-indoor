<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NonLinearFingerprintPositionAndRadioSourceEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-indoor</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.fingerprint</a> &gt; <span class="el_source">NonLinearFingerprintPositionAndRadioSourceEstimator.java</span></div><h1>NonLinearFingerprintPositionAndRadioSourceEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.fingerprint;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.*;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.fitting.FittingException;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFitter;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFunctionEvaluator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * Base class for position and radio source estimators based only on located
 * fingerprints containing RSSI readings.
 * All implementations of this class estimate the position of a new fingerprint
 * and the position of all radio sources associated to fingerprints whose location
 * is known.
 * All implementations solve the problem in a non-linear way using Levenberg-Marquardt
 * algorithm.
 */
public abstract class NonLinearFingerprintPositionAndRadioSourceEstimator&lt;P extends Point&lt;?&gt;&gt; extends
        FingerprintPositionAndRadioSourceEstimator&lt;P&gt; {

    /**
     * Default RSSI standard deviation assumed for provided fingerprints as a fallback
     * when none can be determined.
     */
    public static final double FALLBACK_RSSI_STANDARD_DEVIATION = 1e-3;

    /**
     * Indicates that by default measured RSSI standard deviation of closest fingerprint
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default path-loss exponent standard deviation of radio source
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Small value to be used as machine precision.
     */
    private static final double TINY = 1e-12;

    /**
     * Initial sources whose location is known.
     * If provided, their location will be used as initial values, but
     * after executing this estimator they will be refined.
     */
    protected List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; mInitialLocatedSources;

    /**
     * Initial position to start the estimation.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     */
    private P initialPosition;

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     */
<span class="fc" id="L103">    protected boolean useSourcesPathLossExponentWhenAvailable = true;</span>

    /**
     * RSSI standard deviation fallback value to use when none can be
     * determined from provided readings. This fallback value is only used if
     * no variance is propagated or the resulting value is too small to allow
     * convergence to a solution.
     */
<span class="fc" id="L111">    private double fallbackRssiStandardDeviation = FALLBACK_RSSI_STANDARD_DEVIATION;</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L117">    private boolean propagateFingerprintRssiStandardDeviation = DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION;</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L123">    private boolean propagatePathlossExponentStandardDeviation = DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION;</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L129">    private boolean propagateFingerprintPositionCovariance = DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE;</span>

    /**
     * Indicates whether covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L135">    private boolean propagateRadioSourcePositionCovariance = DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE;</span>

    /**
     * Levenberg-Marquardt fitter to find a non-linear solution.
     */
<span class="fc" id="L140">    private final LevenbergMarquardtMultiDimensionFitter fitter = new LevenbergMarquardtMultiDimensionFitter();</span>

    /**
     * Estimated covariance matrix for estimated non-located fingerprint position and
     * estimated located radio sources position.
     */
    private Matrix covariance;

    /**
     * Covariance of estimated position for non-located fingerprint.
     */
    private Matrix estimatedPositionCovariance;

    /**
     * Estimated chi square value.
     */
    private double chiSq;

    /**
     * Constructor.
     */
<span class="fc" id="L161">    protected NonLinearFingerprintPositionAndRadioSourceEstimator() {</span>
<span class="fc" id="L162">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener in charge of handling events.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L171">        super(listener);</span>
<span class="fc" id="L172">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint) {
<span class="fc" id="L188">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L189">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L207">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L208">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param initialPosition     initial position to be assumed on non located fingerprint or
     *                            null if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition) {
<span class="fc" id="L227">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L228">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L229">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param initialPosition     initial position to be assumed on non located fingerprint or
     *                            null if unknown.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L250">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L251">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L252">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources) {
<span class="fc" id="L271">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L272">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L273">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @param listener              listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L294">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L295">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L296">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialPosition       initial position to be assumed on non located fingerprint or
     *                              null if unknown.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources) {
<span class="fc" id="L318">        this(locatedFingerprints, fingerprint, initialPosition);</span>
<span class="fc" id="L319">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L320">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialPosition       initial position to be assumed on non located fingerprint or
     *                              null if unknown.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @param listener              listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    protected NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L344">        this(locatedFingerprints, fingerprint, initialPosition, listener);</span>
<span class="fc" id="L345">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L346">    }</span>

    /**
     * Gets initial radio sources whose location is known.
     *
     * @return initial radio sources.
     */
    public List&lt;RadioSourceLocated&lt;P&gt;&gt; getInitialLocatedSources() {
        //noinspection unchecked
<span class="fc" id="L355">        return (List&lt;RadioSourceLocated&lt;P&gt;&gt;) mInitialLocatedSources;</span>
    }

    /**
     * Sets initial radio sources whose location is known.
     *
     * @param initialLocatedSources initial radio sources.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialLocatedSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources)
            throws LockedException {
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L367">            throw new LockedException();</span>
        }

<span class="fc" id="L370">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L371">    }</span>

    /**
     * Gets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @return initial position to start the solving algorithm or null.
     */
    public P getInitialPosition() {
<span class="fc" id="L382">        return initialPosition;</span>
    }

    /**
     * Sets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L396">            throw new LockedException();</span>
        }

<span class="fc" id="L399">        this.initialPosition = initialPosition;</span>
<span class="fc" id="L400">    }</span>

    /**
     * Gets estimated covariance matrix for estimated non-located fingerprint position
     * and estimated located radio sources position.
     *
     * @return estimated covariance matrix for estimated non-located fingerprint
     * position and estimated located radio sources position.
     */
    public Matrix getCovariance() {
<span class="fc" id="L410">        return covariance;</span>
    }

    /**
     * Gets covariance of estimated position for non-located fingerprint.
     *
     * @return covariance of estimated position for non-located fingerprint.
     */
    public Matrix getEstimatedPositionCovariance() {
<span class="fc" id="L419">        return estimatedPositionCovariance;</span>
    }

    /**
     * Gets estimated chi square value.
     *
     * @return estimated chi square value.
     */
    public double getChiSq() {
<span class="fc" id="L428">        return chiSq;</span>
    }

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     *
     * @return true to use path loss exponent of provided sources when available,
     * false otherwise.
     */
    public boolean getUseSourcesPathLossExponentWhenAvailable() {
<span class="fc" id="L439">        return useSourcesPathLossExponentWhenAvailable;</span>
    }

    /**
     * Specifies whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     *
     * @param useSourcesPathLossExponentWhenAvailable true to use path loss exponent of
     *                                                provided sources when available,
     *                                                false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseSourcesPathLossExponentWhenAvailable(final boolean useSourcesPathLossExponentWhenAvailable)
            throws LockedException {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L454">            throw new LockedException();</span>
        }
<span class="fc" id="L456">        this.useSourcesPathLossExponentWhenAvailable = useSourcesPathLossExponentWhenAvailable;</span>
<span class="fc" id="L457">    }</span>

    /**
     * Gets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @return RSSI standard deviation fallback.
     */
    public double getFallbackRssiStandardDeviation() {
<span class="fc" id="L466">        return fallbackRssiStandardDeviation;</span>
    }

    /**
     * Sets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @param fallbackRssiStandardDeviation RSSI standard deviation fallback
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is smaller than
     *                                  {@link #TINY}.
     */
    public void setFallbackRssiStandardDeviation(final double fallbackRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L480">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (fallbackRssiStandardDeviation &lt; TINY) {</span>
<span class="nc" id="L483">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L485">        this.fallbackRssiStandardDeviation = fallbackRssiStandardDeviation;</span>
<span class="fc" id="L486">    }</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
<span class="fc" id="L496">        return propagateFingerprintRssiStandardDeviation;</span>
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(final boolean propagateFingerprintRssiStandardDeviation)
            throws LockedException {
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L511">            throw new LockedException();</span>
        }
<span class="fc" id="L513">        this.propagateFingerprintRssiStandardDeviation = propagateFingerprintRssiStandardDeviation;</span>
<span class="fc" id="L514">    }</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
<span class="fc" id="L524">        return propagatePathlossExponentStandardDeviation;</span>
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            final boolean propagatePathlossExponentStandardDeviation) throws LockedException {
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L539">            throw new LockedException();</span>
        }
<span class="fc" id="L541">        this.propagatePathlossExponentStandardDeviation = propagatePathlossExponentStandardDeviation;</span>
<span class="fc" id="L542">    }</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
<span class="fc" id="L551">        return propagateFingerprintPositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(final boolean propagateFingerprintPositionCovariance)
            throws LockedException {
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L565">            throw new LockedException();</span>
        }
<span class="fc" id="L567">        this.propagateFingerprintPositionCovariance = propagateFingerprintPositionCovariance;</span>
<span class="fc" id="L568">    }</span>

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
<span class="fc" id="L577">        return propagateRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(final boolean propagateRadioSourcePositionCovariance)
            throws LockedException {
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L591">            throw new LockedException();</span>
        }
<span class="fc" id="L593">        this.propagateRadioSourcePositionCovariance = propagateRadioSourcePositionCovariance;</span>
<span class="fc" id="L594">    }</span>

    /**
     * Estimates position and radio sources based on provided located radio sources and readings of
     * such radio sources at an unknown location.
     *
     * @throws LockedException                if estimator is locked.
     * @throws NotReadyException              if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException, FingerprintEstimationException {

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L609">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L611" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L612">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L616">            locked = true;</span>

<span class="pc bpc" id="L618" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L619">                listener.onEstimateStart(this);</span>
            }

<span class="fc" id="L622">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanFinder = null;</span>
<span class="fc" id="L623">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">            if (useNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L626">                noMeanFinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints);
            } else {
                //noinspection unchecked
<span class="nc" id="L631">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints);
            }

<span class="fc" id="L636">            estimatedPositionCoordinates = null;</span>
<span class="fc" id="L637">            covariance = null;</span>
<span class="fc" id="L638">            estimatedPositionCovariance = null;</span>
<span class="fc" id="L639">            nearestFingerprints = null;</span>
<span class="fc" id="L640">            estimatedLocatedSources = null;</span>

<span class="fc" id="L642">            final var min = Math.max(1, minNearestFingerprints);</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            final var max = maxNearestFingerprints &lt; 0</span>
<span class="fc" id="L644">                    ? locatedFingerprints.size()</span>
<span class="pc" id="L645">                    : Math.min(maxNearestFingerprints, locatedFingerprints.size());</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">            for (var k = min; k &lt;= max; k++) {</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">                if (noMeanFinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L649">                    nearestFingerprints = noMeanFinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) fingerprint, k);
                } else {
                    //noinspection unchecked
<span class="nc" id="L653">                    nearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) fingerprint, k);
                }

                // Demonstration in 2D:
                // --------------------

                // The expression of received power expressed in dBm's is:
                // k = (c/(4*pi*f))
                // Pr = Pte*k^n / d^n

                // where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                // Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                // Hence:
                // Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //           10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                // where d^2 = dia^2 = (xi - xa)^2 + (yi - ya)^2 is the squared distance between
                // fingerprint and unknown point pi = (xi, yi) and
                // radio source a = a,b... M
                // 10*n*log(k) is constant for a given radio source &quot;a&quot;, and
                // Pte is the equivalent transmitted power of radio source &quot;a&quot;.

                // We assume that the 2 former terms are constant and known for a given radio source
                // K = 10*n*log(k) + 10*log(Pte), and the only unknown term is
                // the latter one depending on the distance of the
                // measuring point and the radio source.

                // Hence for a given radio source &quot;a&quot; at unknown location &quot;i&quot;:
                // Pr(pi) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                // we assume that a known located fingerprint is located at p1 = (x1, y1),
                // Both readings Pr(pi) and Pr(p1) belong to the same radio source &quot;a&quot;, hence
                // K term is the same.

                // Pr(p1) = K - 5*n*log((x1 - xa)^2 + (y1 - ya)^2)

                // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 is the squared distance between
                // fingerprint 1 and radio source 2

                // To remove possible bias effects on readings, we consider the difference of received
                // power for fingerprint &quot;1&quot; and radio source &quot;a&quot; as:

                // Prdiff1a = Pr(pi) - Pr(p1) = (K - 5*n*log(dia^2)) - (K - 5*n*log(d1a^2)) =
                //   = 5*n*log(d1a^2) - 5*n*log(dia^2)

                // where both d1a^2 and dia^2 are unknown, because location pi=(xi,yi) and pa=(xa,ya) are unknown.
                // Now we have no dependencies on the amount of transmitted power of each radio source
                // contained on constant term K, and we only depend on squared distances d1a^2 and dia^2.

                // Consequently, the difference of received power for fingerprint &quot;2&quot; and radio source &quot;a&quot; is:
                // Prdiff2a = 5*n*log(d2a^2) - 5*n*log(dia^2)

                // the difference of received power for fingerprint &quot;1&quot; and radio source &quot;b&quot; is:
                // Prdiff1b = 5*n*log(d1b^2) - 5*n*log(dib^2)

                // and so on.

                // we want to find unknown location pi, and location of radio source pa, pb,... pM so that Prdiff
                // errors are minimized in LMSE (Least Mean Square Error) terms.

                // Assuming that we have M radio sources and N fingerprints, we have
                // y = [Prdiff1a Prdiff2a Prdiff1b Prdiff2b ... PrdiffNa PrdiffNb ... PrdiffNM]

                // and the unknowns to be found are:
                // x = [xi yi xa ya xb yb ... xM yM], which are the location of the unknown fingerprint
                // pi = (xi, yi) and the locations of the radio sources a, b ... M that we want to find pa = (xa, ya),
                // pb = (xb, yb) ... pM = (xM, yM)

                try {
<span class="fc" id="L725">                    final var sourcesToBeEstimated = setupFitter();</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                    if (minNearestFingerprints &lt; 0) {</span>
                        // if no limit is set in minimum value, then a minimum of
                        // dims * (1 + numSources) is used
<span class="fc" id="L729">                        final var numSources = sourcesToBeEstimated.size();</span>
<span class="fc" id="L730">                        final var dims = getNumberOfDimensions();</span>
<span class="fc" id="L731">                        final var minNearest = dims * (1 + numSources);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">                        if (k &lt; minNearest) {</span>
<span class="fc" id="L733">                            continue;</span>
                        }
                    }

<span class="fc" id="L737">                    fitter.fit();</span>

                    // estimated position
<span class="fc" id="L740">                    final var a = fitter.getA();</span>
<span class="fc" id="L741">                    covariance = fitter.getCovar();</span>
<span class="fc" id="L742">                    chiSq = fitter.getChisq();</span>

<span class="fc" id="L744">                    final var dims = getNumberOfDimensions();</span>

                    // obtain estimated position coordinates and covariance
<span class="fc" id="L747">                    estimatedPositionCoordinates = new double[dims];</span>
<span class="fc" id="L748">                    System.arraycopy(a, 0, estimatedPositionCoordinates, 0, dims);</span>

<span class="fc" id="L750">                    final var dimsMinusOne = dims - 1;</span>
<span class="fc" id="L751">                    estimatedPositionCovariance = covariance.getSubmatrix(0, 0, dimsMinusOne,</span>
                            dimsMinusOne);

                    // obtain radio sources estimated positions and covariance
<span class="fc" id="L755">                    final var totalSources = sourcesToBeEstimated.size();</span>
<span class="fc" id="L756">                    estimatedLocatedSources = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                    for (var j = 0; j &lt; totalSources; j++) {</span>
<span class="fc" id="L758">                        final var sourcePosition = createPoint();</span>

<span class="fc" id="L760">                        final var start = dims * (1 + j);</span>
<span class="fc" id="L761">                        final var end = start + dimsMinusOne;</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                        for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L763">                            sourcePosition.setInhomogeneousCoordinate(i, a[start + i]);</span>
                        }

<span class="fc" id="L766">                        final var sourceCovariance = covariance.getSubmatrix(start, start, end, end);</span>

<span class="fc" id="L768">                        final var source = sourcesToBeEstimated.get(j);</span>
<span class="fc" id="L769">                        estimatedLocatedSources.add(createRadioSource(source, sourcePosition, sourceCovariance));</span>
                    }

                    // a solution was found so we exit loop
<span class="fc" id="L773">                    break;</span>
<span class="fc" id="L774">                } catch (final NumericalException e) {</span>
                    // solution could not be found with current data
                    // Iterate to use additional nearby fingerprints
<span class="fc" id="L777">                    estimatedPositionCoordinates = null;</span>
<span class="fc" id="L778">                    covariance = null;</span>
<span class="fc" id="L779">                    estimatedPositionCovariance = null;</span>
<span class="fc" id="L780">                    estimatedLocatedSources = null;</span>
                }
            }

<span class="pc bpc" id="L784" title="1 of 4 branches missed.">            if (estimatedPositionCoordinates == null || estimatedLocatedSources == null) {</span>
                // no position could be estimated
<span class="fc" id="L786">                throw new FingerprintEstimationException();</span>
            }

<span class="pc bpc" id="L789" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L790">                listener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L793">            locked = false;</span>
        }
<span class="fc" id="L795">    }</span>

    /**
     * Propagates provided variances into RSSI differences.
     *
     * @param pathlossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest located fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non-linear algorithm.
     * @param pathlossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null if
     *                                      unknown.
     * @return variance of RSSI difference measured at non located fingerprint reading.
     */
    protected abstract Double propagateVariances(
            final double pathlossExponent, final P fingerprintPosition,
            final P radioSourcePosition, final P estimatedPosition,
            final Double pathlossExponentVariance,
            final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance);

    /**
     * Creates a located radio source from provided radio source, position and
     * covariance.
     *
     * @param source           radio source.
     * @param sourcePosition   radio source position.
     * @param sourceCovariance radio source position covariance.
     * @return located radio source.
     */
    private RadioSourceLocated&lt;P&gt; createRadioSource(
            final RadioSource source, final P sourcePosition, final Matrix sourceCovariance) {

<span class="fc" id="L831">        final var dims = getNumberOfDimensions();</span>

<span class="fc bfc" id="L833" title="All 2 branches covered.">        switch (source.getType()) {</span>
            case BEACON:
<span class="fc" id="L835">                final var beacon = (Beacon) source;</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                if (dims == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {</span>
                    // 2D

                    //noinspection unchecked
<span class="fc" id="L840">                    return (RadioSourceLocated&lt;P&gt;) new BeaconLocated2D(</span>
<span class="fc" id="L841">                            beacon.getIdentifiers(), beacon.getTransmittedPower(),</span>
<span class="fc" id="L842">                            beacon.getFrequency(), beacon.getBluetoothAddress(),</span>
<span class="fc" id="L843">                            beacon.getBeaconTypeCode(), beacon.getManufacturer(),</span>
<span class="fc" id="L844">                            beacon.getServiceUuid(), beacon.getBluetoothName(),</span>
                            (Point2D) sourcePosition, sourceCovariance);
                } else {
                    // 3D

                    //noinspection unchecked
<span class="fc" id="L850">                    return (RadioSourceLocated&lt;P&gt;) new BeaconLocated3D(</span>
<span class="fc" id="L851">                            beacon.getIdentifiers(), beacon.getTransmittedPower(),</span>
<span class="fc" id="L852">                            beacon.getFrequency(), beacon.getBluetoothAddress(),</span>
<span class="fc" id="L853">                            beacon.getBeaconTypeCode(), beacon.getManufacturer(),</span>
<span class="fc" id="L854">                            beacon.getServiceUuid(), beacon.getBluetoothName(),</span>
                            (Point3D) sourcePosition, sourceCovariance);
                }
            case WIFI_ACCESS_POINT:
            default:
<span class="fc" id="L859">                final var accessPoint = (WifiAccessPoint) source;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">                if (dims == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {</span>
                    // 2D

                    //noinspection unchecked
<span class="fc" id="L864">                    return (RadioSourceLocated&lt;P&gt;) new WifiAccessPointLocated2D(</span>
<span class="fc" id="L865">                            accessPoint.getBssid(), accessPoint.getFrequency(),</span>
<span class="fc" id="L866">                            accessPoint.getSsid(), (Point2D) sourcePosition,</span>
                            sourceCovariance);
                } else {
                    // 3D

                    //noinspection unchecked
<span class="fc" id="L872">                    return (RadioSourceLocated&lt;P&gt;) new WifiAccessPointLocated3D(</span>
<span class="fc" id="L873">                            accessPoint.getBssid(), accessPoint.getFrequency(),</span>
<span class="fc" id="L874">                            accessPoint.getSsid(), (Point3D) sourcePosition,</span>
                            sourceCovariance);
                }
        }
    }

    /**
     * Builds data required to solve the problem.
     * This method takes into account current nearest fingerprints and discards those
     * readings belonging to radio sources not having enough data to be estimated.
     *
     * @param allPowerDiffs               list of received power differences of RSSI readings between a
     *                                    located fingerprint and an unknown fingerprint for a given radio
     *                                    source.
     * @param allFingerprintPositions     positions of all located fingerprints being taken into
     *                                    account.
     * @param allInitialSourcesPositions  initial positions of all radio sources to be taken
     *                                    into account. If initial located sources where provided,
     *                                    their positions will be used, otherwise the centroid of
     *                                    all located fingerprints associated to a radio source will
     *                                    be used as initial position.
     * @param allSourcesToBeEstimated     all radio sources that will be estimated.
     * @param allSourcesIndices           indices indicating the position radio source being used
     *                                    within the list of sources for current reading.
     * @param allPathLossExponents        list of path loss exponents.
     * @param allStandardDeviations       list of standard deviations for readings being used.
     * @param nearestFingerprintsCentroid centroid of nearest fingerprints being taken into account.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildData(
            final List&lt;Double&gt; allPowerDiffs,
            final List&lt;P&gt; allFingerprintPositions,
            final List&lt;P&gt; allInitialSourcesPositions,
            final List&lt;RadioSource&gt; allSourcesToBeEstimated,
            final List&lt;Integer&gt; allSourcesIndices,
            final List&lt;Double&gt; allPathLossExponents,
            final List&lt;Double&gt; allStandardDeviations,
            final P nearestFingerprintsCentroid) {

<span class="fc" id="L913">        final var dims = getNumberOfDimensions();</span>
<span class="fc" id="L914">        var num = 0;</span>
<span class="fc" id="L915">        final var centroidCoords = new double[dims];</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">        for (final var fingerprint : nearestFingerprints) {</span>
<span class="fc" id="L917">            final var position = fingerprint.getPosition();</span>
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">            if (position == null) {</span>
<span class="nc" id="L919">                continue;</span>
            }

<span class="fc bfc" id="L922" title="All 2 branches covered.">            for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L923">                centroidCoords[i] += position.getInhomogeneousCoordinate(i);</span>
            }
<span class="fc" id="L925">            num++;</span>
<span class="fc" id="L926">        }</span>

<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        if (num &gt; 0) {</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">            for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L930">                centroidCoords[i] /= num;</span>
<span class="fc" id="L931">                nearestFingerprintsCentroid.setInhomogeneousCoordinate(i, centroidCoords[i]);</span>
            }
        }

        // maps to keep cached in memory computed values to speed up computations
<span class="fc" id="L936">        final var numReadingsMap = new HashMap&lt;RadioSource, Integer&gt;();</span>
<span class="fc" id="L937">        final var centroidsMap = new HashMap&lt;RadioSource, P&gt;();</span>

<span class="fc bfc" id="L939" title="All 2 branches covered.">        for (final var locatedFingerprint : nearestFingerprints) {</span>

<span class="fc" id="L941">            final var locatedReadings = locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">            if (locatedReadings == null) {</span>
<span class="nc" id="L943">                continue;</span>
            }

<span class="fc" id="L946">            final var fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L947">            final var fingerprintPositionCovariance = locatedFingerprint.getPositionCovariance();</span>

<span class="fc bfc" id="L949" title="All 2 branches covered.">            for (final var locatedReading : locatedReadings) {</span>
<span class="fc" id="L950">                final var source = locatedReading.getSource();</span>

                // obtain the total number of readings available for this source and
                // the centroid of all located fingerprints containing readings for
                // such source
                final int numReadings;
<span class="fc bfc" id="L956" title="All 2 branches covered.">                if (!numReadingsMap.containsKey(source)) {</span>
<span class="fc" id="L957">                    numReadings = totalReadingsForSource(source, nearestFingerprints, null);</span>
<span class="fc" id="L958">                    numReadingsMap.put(source, numReadings);</span>
                } else {
<span class="fc" id="L960">                    numReadings = numReadingsMap.get(source);</span>
                }

<span class="fc bfc" id="L963" title="All 2 branches covered.">                if (numReadings &lt; dims) {</span>
<span class="fc" id="L964">                    continue;</span>
                }

                final P centroid;
<span class="fc bfc" id="L968" title="All 2 branches covered.">                if (!centroidsMap.containsKey(source)) {</span>
<span class="fc" id="L969">                    centroid = createPoint();</span>

                    //noinspection unchecked
<span class="fc" id="L972">                    totalReadingsForSource(source,</span>
                            (List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints,
                            centroid);

<span class="fc" id="L976">                    centroidsMap.put(source, centroid);</span>
                } else {
<span class="fc" id="L978">                    centroid = centroidsMap.get(source);</span>
                }

                // find within the list of located sources (if available) the source
                // of current located fingerprint

                //noinspection SuspiciousMethodCalls
<span class="fc bfc" id="L985" title="All 2 branches covered.">                final var pos = mInitialLocatedSources != null ? mInitialLocatedSources.indexOf(source) : -1;</span>

<span class="fc" id="L987">                var pathLossExponent = this.pathLossExponent;</span>
<span class="fc" id="L988">                Double pathLossExponentVariance = null;</span>
<span class="pc bpc" id="L989" title="1 of 4 branches missed.">                if (useSourcesPathLossExponentWhenAvailable &amp;&amp; source instanceof RadioSourceWithPower sourceWithPower) {</span>
<span class="fc" id="L990">                    pathLossExponent = sourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L991">                    final var std = sourceWithPower.getPathLossExponentStandardDeviation();</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">                    pathLossExponentVariance = std != null ? std * std : null;</span>
                }

                final P sourcePosition;
<span class="fc" id="L996">                Matrix sourcePositionCovariance = null;</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">                if (pos &lt; 0) {</span>
                    // located source is not available, so we use centroid
<span class="fc" id="L999">                    sourcePosition = centroid;</span>
                } else {
<span class="fc" id="L1001">                    final var locatedSource = mInitialLocatedSources.get(pos);</span>
<span class="fc" id="L1002">                    sourcePosition = locatedSource.getPosition();</span>

<span class="pc bpc" id="L1004" title="1 of 4 branches missed.">                    if (useSourcesPathLossExponentWhenAvailable</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                            &amp;&amp; locatedSource instanceof RadioSourceWithPower locatedSourceWithPower</span>
                            &amp;&amp; pathLossExponentVariance == null) {
<span class="fc" id="L1007">                        pathLossExponent = locatedSourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L1008">                        final var std = locatedSourceWithPower.getPathLossExponentStandardDeviation();</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">                        pathLossExponentVariance = std != null ? std * std : null;</span>
                    }

<span class="fc" id="L1012">                    sourcePositionCovariance = locatedSource.getPositionCovariance();</span>
                }

                final int sourceIndex;
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                if (!allSourcesToBeEstimated.contains(source)) {</span>
<span class="fc" id="L1017">                    sourceIndex = allSourcesToBeEstimated.size();</span>

<span class="fc" id="L1019">                    allSourcesToBeEstimated.add(source);</span>
<span class="fc" id="L1020">                    allInitialSourcesPositions.add(sourcePosition);</span>
                } else {
<span class="fc" id="L1022">                    sourceIndex = allSourcesToBeEstimated.indexOf(source);</span>
                }

<span class="fc" id="L1025">                final var locatedRssi = locatedReading.getRssi();</span>

<span class="fc" id="L1027">                final var locatedRssiStd = locatedReading.getRssiStandardDeviation();</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                final var locatedRssiVariance = locatedRssiStd != null ? locatedRssiStd * locatedRssiStd : null;</span>

<span class="fc" id="L1030">                final var readings = fingerprint.getReadings();</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">                for (final var reading : readings) {</span>
<span class="pc bpc" id="L1032" title="1 of 4 branches missed.">                    if (reading.getSource() == null || !reading.getSource().equals(source)) {</span>
<span class="fc" id="L1033">                        continue;</span>
                    }

                    // only take into account reading for matching sources on located
                    // and non-located readings
<span class="fc" id="L1038">                    final var rssi = reading.getRssi();</span>

<span class="fc" id="L1040">                    final var powerDiff = rssi - locatedRssi;</span>

<span class="fc" id="L1042">                    Double standardDeviation = null;</span>
<span class="pc bpc" id="L1043" title="5 of 6 branches missed.">                    if (propagatePathlossExponentStandardDeviation || propagateFingerprintPositionCovariance</span>
                            || propagateRadioSourcePositionCovariance) {

                        // compute initial position
<span class="fc bfc" id="L1047" title="All 2 branches covered.">                        final var initialPosition = this.initialPosition != null</span>
<span class="fc" id="L1048">                                ? this.initialPosition : nearestFingerprintsCentroid;</span>

<span class="fc" id="L1050">                        final var variance = propagateVariances(pathLossExponent,</span>
                                fingerprintPosition, sourcePosition, initialPosition,
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">                                propagatePathlossExponentStandardDeviation ? pathLossExponentVariance : null,</span>
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">                                propagateFingerprintPositionCovariance ? fingerprintPositionCovariance : null,</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">                                propagateRadioSourcePositionCovariance ? sourcePositionCovariance : null);</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">                        if (variance != null) {</span>
<span class="fc" id="L1056">                            standardDeviation = Math.sqrt(variance);</span>
                        }
                    }

<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">                    if (standardDeviation == null) {</span>
<span class="nc" id="L1061">                        standardDeviation = reading.getRssiStandardDeviation();</span>
                    }

<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">                    if (propagateFingerprintRssiStandardDeviation) {</span>
<span class="pc bpc" id="L1065" title="2 of 4 branches missed.">                        if (standardDeviation != null &amp;&amp; reading.getRssiStandardDeviation() != null) {</span>
                            // consider propagated variance and reading variance independent, so we
                            // sum them both
<span class="nc" id="L1068">                            standardDeviation = standardDeviation * standardDeviation</span>
<span class="nc" id="L1069">                                    + reading.getRssiStandardDeviation() * reading.getRssiStandardDeviation();</span>
<span class="nc" id="L1070">                            standardDeviation = Math.sqrt(standardDeviation);</span>
                        }

<span class="pc bpc" id="L1073" title="1 of 4 branches missed.">                        if (locatedRssiVariance != null &amp;&amp; standardDeviation != null) {</span>
                            // consider propagated variance and located reading variance
                            // independent, so we sum them both
<span class="fc" id="L1076">                            standardDeviation = standardDeviation * standardDeviation + locatedRssiVariance;</span>
<span class="fc" id="L1077">                            standardDeviation = Math.sqrt(standardDeviation);</span>
                        }
                    }

<span class="pc bpc" id="L1081" title="1 of 4 branches missed.">                    if (standardDeviation == null || standardDeviation &lt; TINY) {</span>
<span class="fc" id="L1082">                        standardDeviation = fallbackRssiStandardDeviation;</span>
                    }

<span class="fc" id="L1085">                    allPowerDiffs.add(powerDiff);</span>
<span class="fc" id="L1086">                    allFingerprintPositions.add(fingerprintPosition);</span>
<span class="fc" id="L1087">                    allSourcesIndices.add(sourceIndex);</span>
<span class="fc" id="L1088">                    allPathLossExponents.add(pathLossExponent);</span>
<span class="fc" id="L1089">                    allStandardDeviations.add(standardDeviation);</span>
<span class="fc" id="L1090">                }</span>
<span class="fc" id="L1091">            }</span>
<span class="fc" id="L1092">        }</span>
<span class="fc" id="L1093">    }</span>

    /**
     * Setups fitter to solve positions.
     *
     * @return list of radio sources whose location will be estimated.
     * @throws FittingException if Levenberg-Marquardt fitting fails.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private List&lt;RadioSource&gt; setupFitter() throws FittingException {
        // build lists of data
<span class="fc" id="L1104">        final var allPowerDiffs = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1105">        final var allFingerprintPositions = new ArrayList&lt;P&gt;();</span>
<span class="fc" id="L1106">        final var allInitialSourcesPositions = new ArrayList&lt;P&gt;();</span>
<span class="fc" id="L1107">        final var allSourcesToBeEstimated = new ArrayList&lt;RadioSource&gt;();</span>
<span class="fc" id="L1108">        final var allSourcesIndices = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L1109">        final var allPathLossExponents = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1110">        final var allStandardDeviations = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1111">        final var nearestFingerprintsCentroid = createPoint();</span>
<span class="fc" id="L1112">        buildData(allPowerDiffs, allFingerprintPositions, allInitialSourcesPositions, allSourcesToBeEstimated,</span>
                allSourcesIndices, allPathLossExponents, allStandardDeviations, nearestFingerprintsCentroid);

<span class="fc" id="L1115">        final var totalReadings = allPowerDiffs.size();</span>
<span class="fc" id="L1116">        final var totalSources = allSourcesToBeEstimated.size();</span>
<span class="fc" id="L1117">        final var dims = getNumberOfDimensions();</span>
<span class="fc" id="L1118">        final var n = 1 + dims;</span>

<span class="fc" id="L1120">        fitter.setFunctionEvaluator(new LevenbergMarquardtMultiDimensionFunctionEvaluator() {</span>
            @Override
            public int getNumberOfDimensions() {
<span class="fc" id="L1123">                return n;</span>
            }

            @Override
            public double[] createInitialParametersArray() {
<span class="fc" id="L1128">                final var initial = new double[dims * (totalSources + 1)];</span>

<span class="fc bfc" id="L1130" title="All 2 branches covered.">                if (initialPosition == null) {</span>
                    // use centroid of nearest fingerprints as initial value
<span class="fc bfc" id="L1132" title="All 2 branches covered.">                    for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1133">                        initial[i] = nearestFingerprintsCentroid.getInhomogeneousCoordinate(i);</span>
                    }
                } else {
                    // use provided initial position
<span class="fc bfc" id="L1137" title="All 2 branches covered.">                    for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1138">                        initial[i] = initialPosition.getInhomogeneousCoordinate(i);</span>
                    }
                }

<span class="fc" id="L1142">                var pos = dims;</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">                for (var j = 0; j &lt; totalSources; j++) {</span>
<span class="fc" id="L1144">                    final var initialSourcePosition = allInitialSourcesPositions.get(j);</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">                    for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1146">                        initial[pos] = initialSourcePosition.getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L1147">                        pos++;</span>
                    }
                }

<span class="fc" id="L1151">                return initial;</span>
            }

            @Override
            public double evaluate(
                    final int i, final double[] point, final double[] params, final double[] derivatives) {

                // For 2D:
                // -------

                // Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
                //   = 5*n*log((x1 - xa)^2 + (y1 - ya)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                // derivatives respect parameters being estimated (xi,yi,xa,ya...,xM,yM)
                // for unknown point pi = (xi, yi)
                // diff(Prdiff1a)/diff(xi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*2*(xi - xa)
                //   = -10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //   = -10*n*(xi - xa)/(log(10)*dia^2)

                // diff(Prdiff1a)/diff(yi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*2*(yi - ya)
                //   = -10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //   = -10*n*(yi - ya)/(log(10)*dia^2)

                // for same radio source pa=(xa,ya)
                // diff(Prdiff1a)/diff(xa) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2))*-2*(x1 - xa) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*-2*(xi - xa) =
                //   = -10*n*(x1 - xa)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2)) + 10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //   = 10*n*(-(x1 - xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                // diff(Prdiff1a)/diff(ya) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2))*-2*(y1 - ya) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*-2*(yi - ya) =
                //   = -10*n*(y1 - ya)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2)) + 10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //   = 10*n*(-(y1 - ya)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                // for other radio source pb=(xb,yb)
                // diff(Prdiff1a)/diff(xb) = diff(Prdiff1a)/diff(yb) = 0

                // For 3D:
                // -------

                // Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
                //   = 5*n*log((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                // derivatives respect parameters being estimated (xi,yi,zi,xa,ya,za...,xM,yM,zM)
                // for unknown point pi = (xi, yi,zi)
                // diff(Prdiff1a)/diff(xi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(xi - xa)
                //   = -10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2) + (zi - za)^2))
                //   = -10*n*(xi - xa)/(log(10)*dia^2)

                // diff(Prdiff1a)/diff(yi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(yi - ya)
                //   = -10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))
                //   = -10*n*(yi - ya)/(log(10)*dia^2)

                // diff(Prdiff1a)/diff(zi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(zi - za)
                //   = -10*n*(zi - za)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))
                //   = -10*n*(zi - za)/(log(10)*dia^2)

                // for same radio source pa=(xa,ya)
                // diff(Prdiff1a)/diff(xa) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(x1 - xa) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(xi - xa) =
                //   = -10*n*(x1 - xa)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //   = 10*n*(-(x1 -xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                // diff(Prdiff1a)/diff(ya) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(y1 - ya) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(yi - ya) =
                //   = -10*n*(y1 - ya)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //   = 10*n(-(y1 - ya)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                // diff(Prdiff1a)/diff(za) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(z1 - za) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(zi - za) =
                //   = -10*n*(z1 - za)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(zi - za)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //   = 10*n(-(z1 - za)/(log(10)*d1a^2) + (zi - za)/(log(10)*dia^2))

                // for other radio source pb=(xb,yb)
                // diff(Prdiff1a)/diff(xb) = diff(Prdiff1a)/diff(yb) = 0

<span class="fc" id="L1222">                final var dims = NonLinearFingerprintPositionAndRadioSourceEstimator.this.getNumberOfDimensions();</span>

                // path loss exponent
<span class="fc" id="L1225">                final var n = point[0];</span>

<span class="fc" id="L1227">                final var ln10 = Math.log(10.0);</span>

<span class="fc" id="L1229">                final var sourceIndex = allSourcesIndices.get(i);</span>
<span class="fc" id="L1230">                final var start = dims * (1 + sourceIndex);</span>

                // d1a^2, d2a^2, ...
<span class="fc" id="L1233">                var distanceFingerprint2 = 0.0;</span>

                // dia^2, dib^2, ...
<span class="fc" id="L1236">                var distancePoint2 = 0.0;</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">                for (var j = 0; j &lt; dims; j++) {</span>
                    // fingerprint coordinate p1=(x1,y1,z1), ...
<span class="fc" id="L1239">                    final var fingerprintCoord = point[1 + j];</span>

                    // unknown point &quot;pi&quot; coordinate
<span class="fc" id="L1242">                    final var pointCoord = params[j];</span>

                    // radio source coordinate pa=(xa,ya,za), ...
<span class="fc" id="L1245">                    final var sourceCoord = params[start + j];</span>

                    // x1 - xa, y1 - ya, ...
<span class="fc" id="L1248">                    final var diffFingerprint = fingerprintCoord - sourceCoord;</span>

                    // xi - xa, yi - ya, ...
<span class="fc" id="L1251">                    final var diffPoint = pointCoord - sourceCoord;</span>

<span class="fc" id="L1253">                    final var diffFingerprint2 = diffFingerprint * diffFingerprint;</span>
<span class="fc" id="L1254">                    final var diffPoint2 = diffPoint * diffPoint;</span>

<span class="fc" id="L1256">                    distanceFingerprint2 += diffFingerprint2;</span>
<span class="fc" id="L1257">                    distancePoint2 += diffPoint2;</span>
                }

<span class="fc" id="L1260">                distanceFingerprint2 = Math.max(distanceFingerprint2, TINY);</span>
<span class="fc" id="L1261">                distancePoint2 = Math.max(distancePoint2, TINY);</span>

<span class="fc" id="L1263">                final var result = 5 * n * (Math.log10(distanceFingerprint2) - Math.log10(distancePoint2));</span>


                // we clear derivatives array to ensure that derivatives respect other
                // radio sources are zero
<span class="fc" id="L1268">                Arrays.fill(derivatives, 0.0);</span>

<span class="fc bfc" id="L1270" title="All 2 branches covered.">                for (var j = 0; j &lt; dims; j++) {</span>
                    // fingerprint coordinate p1=(x1,y1,z1), ...
<span class="fc" id="L1272">                    final var fingerprintCoord = point[1 + j];</span>

                    // unknown point &quot;pi&quot; coordinate
<span class="fc" id="L1275">                    final var pointCoord = params[j];</span>

                    // radio source coordinate pa=(xa,ya,za), ...
<span class="fc" id="L1278">                    final var sourceCoord = params[start + j];</span>

                    // x1 - xa, y1 - ya, ...
<span class="fc" id="L1281">                    final var diffFingerprint = fingerprintCoord - sourceCoord;</span>

                    // xi - xa, yi - ya, ...
<span class="fc" id="L1284">                    final var diffPoint = pointCoord - sourceCoord;</span>

                    // Example: diff(Prdiff1a)/diff(xi) =  -10*n*(xi - xa)/(log(10)*dia^2)
<span class="fc" id="L1287">                    final var derivativePointCoord = -10.0 * n * diffPoint / (ln10 * distancePoint2);</span>

                    // Example: diff(Prdiff1a)/diff(xa) = 10*n*(-(x1 - xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2)) =
                    //   -10*n*(x1 - xa)/(log(10)*d1a^2) - diff(Prdiff1a)/diff(xi)
<span class="fc" id="L1291">                    final var derivativeSameRadioSourceCoord =</span>
                            -10.0 * n * diffFingerprint / (ln10 * distanceFingerprint2) - derivativePointCoord;

                    // derivatives respect point pi = (xi, yi, zi)
<span class="fc" id="L1295">                    derivatives[j] = derivativePointCoord;</span>

                    // derivatives respect same radio source pa = (xa, ya, za)
<span class="fc" id="L1298">                    derivatives[dims * (1 + sourceIndex) + j] = derivativeSameRadioSourceCoord;</span>
                }

<span class="fc" id="L1301">                return result;</span>
            }
        });

        try {
            // In 2D we know that for fingerprint &quot;1&quot; and radio source &quot;a&quot;:
            // Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
            //   = 5*n*log((x1 - xa)^2 + (y1 - ya)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2)

            // Therefore x must have 1 + dims columns (for path-loss n and fingerprint position (x1,y1)

<span class="fc" id="L1312">            final var x = new Matrix(totalReadings, n);</span>
<span class="fc" id="L1313">            final var y = new double[totalReadings];</span>
<span class="fc" id="L1314">            final var standardDeviations = new double[totalReadings];</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">            for (var i = 0; i &lt; totalReadings; i++) {</span>
                // path loss exponent
<span class="fc" id="L1317">                x.setElementAt(i, 0, allPathLossExponents.get(i));</span>

<span class="fc" id="L1319">                final var fingerprintPosition = allFingerprintPositions.get(i);</span>
<span class="fc" id="L1320">                var col = 1;</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">                for (var j = 0; j &lt; dims; j++) {</span>
<span class="fc" id="L1322">                    x.setElementAt(i, col, fingerprintPosition.getInhomogeneousCoordinate(j));</span>
<span class="fc" id="L1323">                    col++;</span>
                }

<span class="fc" id="L1326">                y[i] = allPowerDiffs.get(i);</span>

<span class="fc" id="L1328">                standardDeviations[i] = allStandardDeviations.get(i);</span>
            }

<span class="fc" id="L1331">            fitter.setInputData(x, y, standardDeviations);</span>

<span class="fc" id="L1333">            return allSourcesToBeEstimated;</span>
<span class="fc" id="L1334">        } catch (final AlgebraException e) {</span>
<span class="fc" id="L1335">            throw new FittingException(e);</span>
        }
    }

    /**
     * Gets the total number of readings associated to provided radio source.
     * This method uses only current nearest fingerprints.
     *
     * @param source       radio source to be checked
     * @param centroid     centroid to be computed.
     * @param fingerprints fingerprints where search is made.
     * @return total number of readings associated to provided radio source.
     */
    private int totalReadingsForSource(
            final RadioSource source,
            final List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt; fingerprints,
            final P centroid) {
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L1353">            return 0;</span>
        }

<span class="fc" id="L1356">        final var dims = getNumberOfDimensions();</span>

<span class="fc" id="L1358">        var result = 0;</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">        final var centroidCoords = centroid != null ? new double[dims] : null;</span>

<span class="fc bfc" id="L1361" title="All 2 branches covered.">        for (final var fingerprint : fingerprints) {</span>
<span class="fc" id="L1362">            final var readings = fingerprint.getReadings();</span>
<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">            if (readings == null) {</span>
<span class="nc" id="L1364">                continue;</span>
            }

<span class="fc" id="L1367">            final var fingerprintPosition = fingerprint.getPosition();</span>

<span class="fc bfc" id="L1369" title="All 2 branches covered.">            for (final var reading : readings) {</span>
<span class="fc" id="L1370">                final var readingSource = reading.getSource();</span>
<span class="pc bpc" id="L1371" title="1 of 4 branches missed.">                if (readingSource != null &amp;&amp; readingSource.equals(source)) {</span>
<span class="fc" id="L1372">                    result++;</span>

<span class="fc bfc" id="L1374" title="All 2 branches covered.">                    if (centroid != null) {</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                        for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1376">                            final var coord = fingerprintPosition.getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L1377">                            centroidCoords[i] += coord;</span>
                        }
                    }
                }
<span class="fc" id="L1381">            }</span>
<span class="fc" id="L1382">        }</span>

<span class="pc bpc" id="L1384" title="1 of 4 branches missed.">        if (centroid != null &amp;&amp; result &gt; 0) {</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">            for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1386">                centroidCoords[i] /= result;</span>
<span class="fc" id="L1387">                centroid.setInhomogeneousCoordinate(i, centroidCoords[i]);</span>
            }
        }

<span class="fc" id="L1391">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>