<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NonLinearFingerprintPositionEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-indoor</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.fingerprint</a> &gt; <span class="el_source">NonLinearFingerprintPositionEstimator.java</span></div><h1>NonLinearFingerprintPositionEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.fingerprint;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.RadioSource;
import com.irurueta.navigation.indoor.RadioSourceKNearestFinder;
import com.irurueta.navigation.indoor.RadioSourceLocated;
import com.irurueta.navigation.indoor.RadioSourceNoMeanKNearestFinder;
import com.irurueta.navigation.indoor.RadioSourceWithPower;
import com.irurueta.navigation.indoor.RssiFingerprint;
import com.irurueta.navigation.indoor.RssiFingerprintLocated;
import com.irurueta.navigation.indoor.RssiReading;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.fitting.FittingException;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFitter;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFunctionEvaluator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Base class for position estimators based on located fingerprints containing only
 * RSSI readings and having as well prior knowledge of the location of radio sources
 * associated to those readings.
 * This implementation uses a Taylor approximation over provided located
 * fingerprints to determine an approximate position for a non-located fingerprint using
 * a non-linear solving algorithm.
 * An initial position can be provided as a starting point to solve the position,
 * otherwise the average point of selected nearest fingerprints is used as a starting
 * point.
 *
 * @param &lt;P&gt; a {@link Point} type.
 */
public abstract class NonLinearFingerprintPositionEstimator&lt;P extends Point&lt;?&gt;&gt; extends
        FingerprintPositionEstimator&lt;P&gt; {

    /**
     * Default RSSI standard deviation assumed for provided fingerprints as a fallback
     * when none can be determined.
     */
    public static final double FALLBACK_RSSI_STANDARD_DEVIATION = 1.0;

    /**
     * Indicates that by default measured RSSI standard deviation of closest fingerprint
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default path-loss exponent standard deviation of radio source
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Default type to be used when none is provided.
     */
<span class="fc" id="L89">    public static final NonLinearFingerprintPositionEstimatorType DEFAULT_TYPE =</span>
            NonLinearFingerprintPositionEstimatorType.THIRD_ORDER;

    /**
     * Small value to be used as the minimum allowed RSSI standard deviations. A value
     * larger than this must be provided to allow convergence to a solution
     */
    public static final double TINY_RSSI_STD = 1e-12;

    /**
     * Initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     */
    private P mInitialPosition;

    /**
     * RSSI standard deviation fallback value to use when none can be
     * determined from provided readings. This fallback value is only used if
     * no variance is propagated or the resulting value is too small to allow
     * convergence to a solution.
     */
<span class="fc" id="L112">    private double mFallbackRssiStandardDeviation =</span>
            FALLBACK_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L119">    private boolean mPropagateFingerprintRssiStandardDeviation =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L126">    private boolean mPropagatePathlossExponentStandardDeviation =</span>
            DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION;

    /**
     * Indicates whether covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L133">    private boolean mPropagateFingerprintPositionCovariance =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE;

    /**
     * Indicates whether covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L140">    private boolean mPropagateRadioSourcePositionCovariance =</span>
            DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE;

    /**
     * Levenberg-Marquardt fitter to find a non-linear solution.
     */
<span class="fc" id="L146">    private final LevenbergMarquardtMultiDimensionFitter mFitter = new LevenbergMarquardtMultiDimensionFitter();</span>

    /**
     * Estimated covariance matrix for estimated position.
     */
    private Matrix mCovariance;

    /**
     * Estimated chi square value.
     */
    private double mChiSq;

    /**
     * Constructor.
     */
<span class="fc" id="L161">    protected NonLinearFingerprintPositionEstimator() {</span>
<span class="fc" id="L162">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener in charge of handling events.
     */
    protected NonLinearFingerprintPositionEstimator(
            final FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L171">        super(listener);</span>
<span class="fc" id="L172">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    protected NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
<span class="fc" id="L195">        super(locatedFingerprints, fingerprint, sources);</span>
<span class="fc" id="L196">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    protected NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources,
            final FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L221">        super(locatedFingerprints, fingerprint, sources, listener);</span>
<span class="fc" id="L222">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @param initialPosition     initial position to start the solving algorithm or null.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    protected NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources, P initialPosition) {
<span class="fc" id="L246">        super(locatedFingerprints, fingerprint, sources);</span>
<span class="fc" id="L247">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L248">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @param initialPosition     initial position to start the solving algorithm or null.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    protected NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources, P initialPosition,
            final FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L274">        super(locatedFingerprints, fingerprint, sources, listener);</span>
<span class="fc" id="L275">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L276">    }</span>

    /**
     * Gets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @return initial position to start the solving algorithm or null.
     */
    public P getInitialPosition() {
<span class="fc" id="L287">        return mInitialPosition;</span>
    }

    /**
     * Sets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L301">            throw new LockedException();</span>
        }

<span class="fc" id="L304">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L305">    }</span>

    /**
     * Gets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @return RSSI standard deviation fallback.
     */
    public double getFallbackRssiStandardDeviation() {
<span class="fc" id="L314">        return mFallbackRssiStandardDeviation;</span>
    }

    /**
     * Sets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @param fallbackRssiStandardDeviation RSSI standard deviation fallback
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is smaller than
     *                                  {@link #TINY_RSSI_STD}.
     */
    public void setFallbackRssiStandardDeviation(
            final double fallbackRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L329">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (fallbackRssiStandardDeviation &lt; TINY_RSSI_STD) {</span>
<span class="nc" id="L332">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L334">        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;</span>
<span class="fc" id="L335">    }</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
<span class="fc" id="L345">        return mPropagateFingerprintRssiStandardDeviation;</span>
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            final boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L360">            throw new LockedException();</span>
        }
<span class="fc" id="L362">        mPropagateFingerprintRssiStandardDeviation =</span>
                propagateFingerprintRssiStandardDeviation;
<span class="fc" id="L364">    }</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
<span class="fc" id="L374">        return mPropagatePathlossExponentStandardDeviation;</span>
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            final boolean propagatePathlossExponentStandardDeviation) throws LockedException {
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L389">            throw new LockedException();</span>
        }
<span class="fc" id="L391">        mPropagatePathlossExponentStandardDeviation =</span>
                propagatePathlossExponentStandardDeviation;
<span class="fc" id="L393">    }</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
<span class="fc" id="L402">        return mPropagateFingerprintPositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            final boolean propagateFingerprintPositionCovariance) throws LockedException {
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L416">            throw new LockedException();</span>
        }
<span class="fc" id="L418">        mPropagateFingerprintPositionCovariance =</span>
                propagateFingerprintPositionCovariance;
<span class="fc" id="L420">    }</span>

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
<span class="fc" id="L429">        return mPropagateRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            final boolean propagateRadioSourcePositionCovariance) throws LockedException {
<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L443">            throw new LockedException();</span>
        }
<span class="fc" id="L445">        mPropagateRadioSourcePositionCovariance =</span>
                propagateRadioSourcePositionCovariance;
<span class="fc" id="L447">    }</span>

    /**
     * Gets estimated covariance matrix for estimated position.
     *
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getCovariance() {
<span class="fc" id="L455">        return mCovariance;</span>
    }

    /**
     * Gets estimated chi square value.
     *
     * @return estimated chi square value.
     */
    public double getChiSq() {
<span class="fc" id="L464">        return mChiSq;</span>
    }

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     *
     * @throws LockedException                if estimator is locked.
     * @throws NotReadyException              if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L481">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L484">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L488">            locked = true;</span>

<span class="pc bpc" id="L490" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L491">                listener.onEstimateStart(this);</span>
            }

<span class="fc" id="L494">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanFinder = null;</span>
<span class="fc" id="L495">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            if (useNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L498">                noMeanFinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints);
            } else {
                //noinspection unchecked
<span class="fc" id="L503">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints);
            }

<span class="fc" id="L508">            estimatedPositionCoordinates = null;</span>
<span class="fc" id="L509">            mCovariance = null;</span>
<span class="fc" id="L510">            nearestFingerprints = null;</span>

<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            final int max = maxNearestFingerprints &lt; 0 ?</span>
<span class="fc" id="L513">                    locatedFingerprints.size() :</span>
<span class="pc" id="L514">                    Math.min(maxNearestFingerprints, locatedFingerprints.size());</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">            for (int k = minNearestFingerprints; k &lt;= max; k++) {</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                if (noMeanFinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L518">                    nearestFingerprints = noMeanFinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) fingerprint, k);
                } else {
                    //noinspection unchecked
<span class="fc" id="L522">                    nearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) fingerprint, k);
                }

                // Demonstration in 2D:
                // --------------------
                // Taylor series expansion can be expressed as:
                // f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                // where f'(x) is the derivative of f respect x, which can also be expressed as:
                // f'(x) = diff(f(x))/diff(x)

                // and f'(a) is the derivative of f respect x evaluated at &quot;a&quot;, which can be expressed
                // as f'(a) = diff(f(a))/diff(x)

                // consequently f''(a) is the second derivative respect x evaluated at &quot;a&quot;, which can
                // be expressed as:
                // f''(x) = diff(f(x))/diff(x^2)

                // and:
                // f''(a) = diff(f(a))/diff(x^2)

                // Received power expressed in dBm is:
                // k = (c/(4*pi*f))
                // Pr = Pte*k^n / d^n

                // where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                // Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                // Hence:
                // Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //           10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                // The former 2 terms are constant, and only the last term depends on distance

                // Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                // assuming that transmitted power by the radio source Pte is known (so that K is also known),
                // and assuming that the location of the radio source is known, and it is located at pa = (xa, ya)
                // so that d^2 = (x - xa)^2 + (y - ya)^2 then the received power at an unknown point pi = (xi, yi) is:

                // Pr(pi) = Pr(xi,yi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                // Suppose that received power at point p1=(x1,y1) is known on a located fingerprint
                // containing readings Pr(p1).

                // Then, for an unknown point pi=(xi,yi) close to fingerprint 1 located at p1 where we
                // have measured received power Pr(pi), we can get the following second-order Taylor
                // approximation:

                // Pr(pi) ~ Pr(p1) + JPr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                // where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                // with scalar result, the Jacobian has size 1x2 and is equal to the gradient.
                // HPr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 2x2,
                // and (pi-p1)^T is the transposed vector of (pi-p1)

                // Hence, the Jacobian at any point p=(x,y) is equal to:
                // JPr(p = (x,y)) = [diff(Pr(x,y))/diff(x)   diff(Pr(x,y))/diff(y)]

                // And the Hessian matrix is equal to
                // HPr(p = (x,y)) =  [diff(Pr(x,y))/diff(x^2)    diff(Pr(x,y))/diff(x*y)]
                //                   [diff(Pr(x,y))/diff(x*y)    diff(Pr(x,y))/diff(y^2)]

                // where the first order derivatives of Pr(p = (x,y)) are:
                // diff(Pr(x,y))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(x - xa)
                // diff(Pr(x,y))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                // diff(Pr(x,y))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(y - ya)
                // diff(Pr(x,y))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                // If we evaluate first order derivatives at p1 = (x1,y1), we get:
                // diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))
                // diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                // where square distance from fingerprint 1 to radio source a can be expressed as:
                // d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                // where both the fingerprint and radio source positions are known, and hence d1a is known.

                // Then first order derivatives can be expressed as:
                // diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                // diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)

                // To obtain second order derivatives we take into account that:
                // (f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2

                // hence, second order derivatives of Pr(p = (x,y)) are:
                // diff(Pr(x,y))/diff(x^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2) - (x - xa)*2*(x - xa)) / ((x - xa)^2 + (y - ya)^2)^2
                // diff(Pr(x,y))/diff(x^2) = -10*n*((y - ya)^2 - (x - xa)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                // diff(Pr(x,y))/diff(y^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2) - (y - ya)*2*(y - ya)) / ((x - xa)^2 + (y - ya)^2)^2
                // diff(Pr(x,y))/diff(y^2) = -10*n*((x - xa)^2 - (y - ya)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                // diff(Pr(x,y))/diff(x*y) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2) - (x - xa)*2*(y - ya))/((x - xa)^2 + (y - ya)^2)^2
                // diff(Pr(x,y))/diff(x*y) = 20*n*((x - xa)*(y - ya))/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                // If we evaluate second order derivatives at p1 = (x1,y1), we get:
                // diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 - (x1 - xa)^2))/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)
                // diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)
                // diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)

                // and expressing the second order derivatives in terms of distance between
                // fingerprint 1 and radio source a d1a, we get:
                // diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 - (x1 - xa)^2))/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)

                // Hence, second order Taylor expansion can be expressed as:
                // Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1) +
                // 1/2*diff(Pr(p1))/diff(x^2)*(xi - x1)^2 + 1/2*diff(Pr(p1))/diff(y^2)*(yi - y1)^2 +
                // diff(Pr(p1))/diff(x*y)*(xi - x1)*(yi - y1)

                // Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1) -10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                // - 5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
                // - 5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2 +
                // 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4))*(xi - x1)*(yi - y1)

                // The equation above can be solved using a non-linear fitter such as Levenberg-Marquardt


                // Demonstration in 3D:
                // --------------------
                // Taylor series expansion can be expressed as:
                // f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                // where f'(x) is the derivative of f respect x, which can also be expressed as:
                // f'(x) = diff(f(x))/diff(x)

                // and f'(a) is the derivative of f respect x evaluated at &quot;a&quot;, which can be expressed
                // as f'(a) = diff(f(a))/diff(x)

                // consequently f''(a) is the second derivative respect x evaluated at &quot;a&quot;, which can
                // be expressed as:
                // f''(x) = diff(f(x))/diff(x^2)

                // and:
                // f''(a) = diff(f(a))/diff(x^2)

                // Received power expressed in dBm is:
                // k = (c/(4*pi*f))
                // Pr = Pte*k^n / d^n

                // where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                // Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                // Hence:
                // Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                // The former 2 terms are constant, and only the last term depends on distance

                // Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                // assuming that transmitted power by the radio source Pte is known (so that K is also known),
                // and assuming that the location of the radio source is known, and it is located at pa = (xa, ya, za)
                // so that d^2 = (x - xa)^2 + (y - ya)^2 + (z - za)^2 then the received power at an unknown point
                // pi = (xi, yi, zi) is:

                // Pr(pi) = Pr(xi,yi,zi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                // Suppose that received power at point p1=(x1,y1,z1) is known on a located fingerprint
                // containing readings Pr(p1).

                // Then, for an unknown point pi=(xi,yi,zi) close to fingerprint 1 located at p1 where we
                // have measured received power Pr(pi), we can get the following second-order Taylor
                // approximation:

                // Pr(pi) ~ Pr(p1) + JPtr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                // where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                // with scalar result, the Jacobian has size 1x3 and is equal to the gradient.
                // HPtr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 3x3,
                // and (pi-p1)^T is the transposed vector of (pi-p1)

                // Hence, the Jacobian at any point p=(x,y,z) is equal to:
                // JPr(p = (x,y,z)) = [diff(Pr(x,y,z))/diff(x)     diff(Pr(x,y,z))/diff(y)     diff(Pr(x,y,z))/diff(z)]

                // And the Hessian matrix is equal to
                // HPr(p = (x,y,z)) = [diff(Pr(x,y,z))/diff(x^2)    diff(Pr(x,y,z))/diff(x*y)     diff(Pr(x,y,z))/diff(x*z)]
                //                    [diff(Pr(x,y,z))/diff(x*y)    diff(Pr(x,y,z))/diff(y^2)     diff(Pr(x,y,z))/diff(y*z)]
                //                    [diff(Pr(x,y,z))/diff(x*z)    diff(Pr(x,y,z))/diff(y*z)     diff(Pr(x,y,z))/diff(z^2)]

                // where the first order derivatives of Pr(p = (x,y)) are:
                // diff(Pr(x,y,z))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(x - xa)
                // diff(Pr(x,y,z))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                // diff(Pr(x,y,z))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(y - ya)
                // diff(Pr(x,y,z))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                // diff(Pr(x,y,z))/diff(z) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(z - za)
                // diff(Pr(x,y,z))/diff(z) = -10*n*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                // If we evaluate derivatives at p1 = (x1,y1,z1), we get:
                // diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                // diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                // diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                // where square distance from fingerprint 1 to radio source a can be expressed as:
                // d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                // where both the fingerprint and radio source positions are known, and hence d1a is known.

                // Then first order derivatives can be expressed as:
                // diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                // diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)
                // diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*d1a^2)

                // To obtain second order derivatives we take into account that:
                // (f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2

                // hence, second order derivatives of Pr(p = (x,y,z)) are:
                // diff(Pr(x,y,z))/diff(x^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(x - xa))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                // diff(Pr(x,y,z))/diff(x^2) = -10*n*((y - ya)^2 + (z - za)^2 - (x - xa)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                // diff(Pr(x,y,z))/diff(y^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (y - ya)*2*(y - ya))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                // diff(Pr(x,y,z))/diff(y^2) = -10*n*((x - xa)^2 - (y - ya)^2 + (z - za)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                // diff(Pr(x,y,z))/diff(z^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (z - za)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                // diff(Pr(x,y,z))/diff(z^2) = -10*n*((x - xa)^2 + (y - ya)^2 - (z - za)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                // diff(Pr(x,y,z))/diff(x*y) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(y - ya))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                // diff(Pr(x,y,z))/diff(x*y) = 20*n*(x - xa)*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                // diff(Pr(x,y,z))/diff(x*z) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                // diff(Pr(x,y,z))/diff(x*z) = 20*n*(x - xa)*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                // diff(Pr(x,y,z))/diff(y*z) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (y - ya)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                // diff(Pr(x,y,z))/diff(y*z) = 20*n*(y - ya)*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                // If we evaluate second order derivatives at p1 = (x1,y1,z1), we get:
                // diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                // diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                // diff(Pr(p1))/diff(z^2) = -10*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                // diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                // diff(Pr(p1))/diff(x*z) = 20*n*(x1 - xa)*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                // diff(Pr(p1))/diff(y*z) = 20*n*(y1 - ya)*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)

                // and expressing the second order derivatives in terms of distance between
                // fingerprint 1 and radio source a d1a, we get:
                // diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(z^2) = -10*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(x*z) = 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)
                // diff(Pr(p1))/diff(y*z) = 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)

                // Hence, second order Taylor expansion can be expressed as:
                // Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(x - x1) +
                //       diff(Pr(p1))/diff(y)*(y - y1) +
                //       diff(Pr(p1))/diff(z)*(z - z1) +
                //       1/2*diff(Pr(p1))/diff(x^2)*(x - x1)^2 +
                //       1/2*diff(Pr(p1))/diff(y^2)*(y - y1)^2 +
                //	     1/2*diff(Pr(p1))/diff(z^2)*(z - z1)^2 +
                //	     diff(Pr(p1))/diff(x*y)*(x - x1)*(y - y1) +
                //	     diff(Pr(p1))/diff(y*z)*(y - y1)*(z - z1) +
                //	     diff(Pr(p1))/diff(x*z)*(x - x1)*(z - z1)

                // Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi -x1)
                //       - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                //       - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
                //       - 5*n*((y1 - ya)^2 + (z1 - za)^2) - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
                //       - 5*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2))/(ln(10)*d1a^4)*(yi - y1)^2
                //       - 5*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2))/(ln(10)*d1a^4)*(zi - z1)^2
                //       + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1)
                //       + 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)*(yi - y1)*(zi - z1)
                //       + 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)*(xi - x1)*(zi - z1)

                // The equation above can be solved using a non-linear fitter such as Levenberg-Marquardt
                try {
<span class="fc" id="L792">                    setupFitter();</span>

<span class="fc" id="L794">                    mFitter.fit();</span>

                    // estimated position
<span class="fc" id="L797">                    estimatedPositionCoordinates = mFitter.getA();</span>
<span class="fc" id="L798">                    mCovariance = mFitter.getCovar();</span>
<span class="fc" id="L799">                    mChiSq = mFitter.getChisq();</span>

                    // a solution was found so we exit loop
<span class="fc" id="L802">                    break;</span>
<span class="fc" id="L803">                } catch (NumericalException e) {</span>
                    // solution could not be found with current data
                    // Iterate to use additional nearby fingerprints
<span class="fc" id="L806">                    estimatedPositionCoordinates = null;</span>
<span class="fc" id="L807">                    mCovariance = null;</span>
<span class="fc" id="L808">                    nearestFingerprints = null;</span>
                }
            }

<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            if (estimatedPositionCoordinates == null) {</span>
                // no solution could be found
<span class="nc" id="L814">                throw new FingerprintEstimationException();</span>
            }

<span class="pc bpc" id="L817" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L818">                listener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L821">            locked = false;</span>
        }
<span class="fc" id="L823">    }</span>

    /**
     * Gets type of position estimator.
     *
     * @return type of position estimator.
     */
    public abstract NonLinearFingerprintPositionEstimatorType getType();

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     *
     * @param i           number of sample being evaluated.
     * @param point       point where function will be evaluated.
     * @param params      initial parameters estimation to be tried. These will
     *                    change as the Levenberg-Marquardt algorithm iterates to the best solution.
     *                    These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     *                    provided parameter.
     * @return function evaluation at provided point.
     */
    protected abstract double evaluate(
            final int i, final double[] point, final double[] params, final double[] derivatives);

    /**
     * Propagates provided variances into RSSI variance of non-located fingerprint
     * reading.
     *
     * @param fingerprintRssi               closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathlossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest located fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non-linear algorithm.
     * @param fingerprintRssiVariance       variance of fingerprint RSSI or null if unknown.
     * @param pathlossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null if
     *                                      unknown.
     * @return variance of RSSI measured at non located fingerprint reading.
     */
    protected abstract Double propagateVariances(
            final double fingerprintRssi, final double pathlossExponent, final P fingerprintPosition,
            final P radioSourcePosition, final P estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathlossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance);

    /**
     * Builds data required to solve the problem.
     *
     * @param allReceivedPower        list of received powers for readings at unknown positions.
     * @param allFingerprintPower     list of power readings at fingerprint positions.
     * @param allFingerprintPositions list of fingerprint positions.
     * @param allSourcesPositions     list of radio sources positions.
     * @param allPathLossExponents    list of path loss exponents.
     * @param allStandardDeviations   list of standard deviations for readings being used.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildData(
            final List&lt;Double&gt; allReceivedPower,
            final List&lt;Double&gt; allFingerprintPower,
            final List&lt;P&gt; allFingerprintPositions,
            final List&lt;P&gt; allSourcesPositions,
            final List&lt;Double&gt; allPathLossExponents,
            final List&lt;Double&gt; allStandardDeviations) {
<span class="fc bfc" id="L891" title="All 2 branches covered.">        for (final var locatedFingerprint : nearestFingerprints) {</span>

<span class="fc" id="L893">            final var locatedReadings = locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">            if (locatedReadings == null) {</span>
<span class="nc" id="L895">                continue;</span>
            }

<span class="fc" id="L898">            final var fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L899">            final var fingerprintPositionCovariance = locatedFingerprint.getPositionCovariance();</span>

<span class="fc" id="L901">            var locatedMeanRssi = 0.0;</span>
<span class="fc" id="L902">            var meanRssi = 0.0;</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">            if (removeMeansFromFingerprintReadings) {</span>
<span class="fc" id="L904">                locatedMeanRssi = locatedFingerprint.getMeanRssi();</span>
            }

<span class="fc bfc" id="L907" title="All 2 branches covered.">            for (final var locatedReading : locatedReadings) {</span>
<span class="fc" id="L908">                final var source = locatedReading.getSource();</span>

                // find within the list of located sources the source of
                // current located fingerprint reading.
                // Radio sources are compared by their id
                // regardless of them being located or not

                //noinspection SuspiciousMethodCalls
<span class="fc" id="L916">                final var pos = sources.indexOf(source);</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">                if (pos &lt; 0) {</span>
<span class="nc" id="L918">                    continue;</span>
                }

<span class="fc" id="L921">                final var locatedSource = sources.get(pos);</span>
<span class="fc" id="L922">                var pathLossExponent = this.pathLossExponent;</span>
<span class="fc" id="L923">                Double pathLossExponentVariance = null;</span>
<span class="pc bpc" id="L924" title="1 of 4 branches missed.">                if (useSourcesPathLossExponentWhenAvailable</span>
<span class="fc" id="L925">                        &amp;&amp; locatedSource instanceof RadioSourceWithPower locatedSourceWithPower) {</span>
<span class="fc" id="L926">                    pathLossExponent = locatedSourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L927">                    final var std = locatedSourceWithPower.getPathLossExponentStandardDeviation();</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">                    pathLossExponentVariance = std != null ? std * std : null;</span>
                }

<span class="fc" id="L931">                final var sourcePosition = locatedSource.getPosition();</span>
<span class="fc" id="L932">                final var sourcePositionCovariance = locatedSource.getPositionCovariance();</span>
<span class="fc" id="L933">                var locatedRssi = locatedReading.getRssi();</span>
<span class="fc" id="L934">                locatedRssi -= locatedMeanRssi;</span>

<span class="fc" id="L936">                final var locatedRssiStd = locatedReading.getRssiStandardDeviation();</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">                final var locatedRssiVariance = locatedRssiStd != null ? locatedRssiStd * locatedRssiStd : null;</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">                if (removeMeansFromFingerprintReadings) {</span>
<span class="fc" id="L939">                    meanRssi = fingerprint.getMeanRssi();</span>
                }

<span class="fc" id="L942">                final var readings = fingerprint.getReadings();</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">                for (final var reading : readings) {</span>
<span class="pc bpc" id="L944" title="1 of 4 branches missed.">                    if (reading.getSource() == null || !reading.getSource().equals(locatedSource)) {</span>
<span class="fc" id="L945">                        continue;</span>
                    }

                    // only take into account reading for matching sources on located and
                    // non-located readings
<span class="fc" id="L950">                    var rssi = reading.getRssi();</span>
<span class="fc" id="L951">                    rssi -= meanRssi;</span>

<span class="fc" id="L953">                    Double standardDeviation = null;</span>
<span class="pc bpc" id="L954" title="7 of 8 branches missed.">                    if (mPropagateFingerprintRssiStandardDeviation || mPropagatePathlossExponentStandardDeviation</span>
                            || mPropagateFingerprintPositionCovariance || mPropagateRadioSourcePositionCovariance) {

                        // compute initial position
<span class="fc bfc" id="L958" title="All 2 branches covered.">                        final var initialPosition = mInitialPosition != null ? mInitialPosition : fingerprintPosition;</span>

<span class="fc" id="L960">                        final var variance = propagateVariances(locatedRssi, pathLossExponent, fingerprintPosition,</span>
                                sourcePosition, initialPosition,
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">                                mPropagateFingerprintRssiStandardDeviation ? locatedRssiVariance : null,</span>
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">                                mPropagatePathlossExponentStandardDeviation ? pathLossExponentVariance : null,</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">                                mPropagateFingerprintPositionCovariance ? fingerprintPositionCovariance : null,</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">                                mPropagateRadioSourcePositionCovariance ? sourcePositionCovariance : null);</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">                        if (variance != null) {</span>
<span class="fc" id="L967">                            standardDeviation = Math.sqrt(variance);</span>
                        }
                    }

<span class="pc bpc" id="L971" title="1 of 2 branches missed.">                    if (standardDeviation == null) {</span>
<span class="nc" id="L972">                        standardDeviation = reading.getRssiStandardDeviation();</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                    } else if (reading.getRssiStandardDeviation() != null) {</span>
                        // consider propagated variance and reading variance independent, so we
                        // sum them both
<span class="nc" id="L976">                        standardDeviation = standardDeviation * standardDeviation +</span>
<span class="nc" id="L977">                                reading.getRssiStandardDeviation() * reading.getRssiStandardDeviation();</span>
<span class="nc" id="L978">                        standardDeviation = Math.sqrt(standardDeviation);</span>
                    }

<span class="pc bpc" id="L981" title="1 of 4 branches missed.">                    if (standardDeviation == null || standardDeviation &lt; TINY_RSSI_STD) {</span>
<span class="fc" id="L982">                        standardDeviation = mFallbackRssiStandardDeviation;</span>
                    }

<span class="fc" id="L985">                    allReceivedPower.add(rssi);</span>
<span class="fc" id="L986">                    allFingerprintPower.add(locatedRssi);</span>
<span class="fc" id="L987">                    allFingerprintPositions.add(fingerprintPosition);</span>
<span class="fc" id="L988">                    allSourcesPositions.add(sourcePosition);</span>
<span class="fc" id="L989">                    allPathLossExponents.add(pathLossExponent);</span>
<span class="fc" id="L990">                    allStandardDeviations.add(standardDeviation);</span>
<span class="fc" id="L991">                }</span>
<span class="fc" id="L992">            }</span>
<span class="fc" id="L993">        }</span>
<span class="fc" id="L994">    }</span>

    /**
     * Setups fitter to solve position.
     *
     * @throws FittingException if Levenberg-Marquardt fitting fails.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void setupFitter() throws FittingException {
        // build lists of data
<span class="fc" id="L1004">        final var allReceivedPower = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1005">        final var allFingerprintPower = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1006">        final var allFingerprintPositions = new ArrayList&lt;P&gt;();</span>
<span class="fc" id="L1007">        final var allSourcesPosition = new ArrayList&lt;P&gt;();</span>
<span class="fc" id="L1008">        final var allPathLossExponents = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1009">        final var allStandardDeviations = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L1010">        buildData(allReceivedPower, allFingerprintPower, allFingerprintPositions, allSourcesPosition,</span>
                allPathLossExponents, allStandardDeviations);

<span class="fc" id="L1013">        final var totalReadings = allReceivedPower.size();</span>
<span class="fc" id="L1014">        final var dims = getNumberOfDimensions();</span>
<span class="fc" id="L1015">        final var n = 2 + 2 * dims;</span>

<span class="fc" id="L1017">        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiDimensionFunctionEvaluator() {</span>
            @Override
            public int getNumberOfDimensions() {
<span class="fc" id="L1020">                return n;</span>
            }

            @Override
            public double[] createInitialParametersArray() {

<span class="fc" id="L1026">                final var initial = new double[dims];</span>

<span class="fc bfc" id="L1028" title="All 2 branches covered.">                if (mInitialPosition == null) {</span>
                    // use centroid of nearest fingerprints as initial value
<span class="fc" id="L1030">                    var num = 0;</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">                    for (var fingerprint : nearestFingerprints) {</span>
<span class="fc" id="L1032">                        final var position = fingerprint.getPosition();</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">                        if (position == null) {</span>
<span class="nc" id="L1034">                            continue;</span>
                        }

<span class="fc bfc" id="L1037" title="All 2 branches covered.">                        for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1038">                            initial[i] += position.getInhomogeneousCoordinate(i);</span>
                        }
<span class="fc" id="L1040">                        num++;</span>
<span class="fc" id="L1041">                    }</span>

<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">                    if (num &gt; 0) {</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                        for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1045">                            initial[i] /= num;</span>
                        }
                    }
<span class="fc" id="L1048">                } else {</span>
                    // use provided initial position
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                    for (var i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1051">                        initial[i] = mInitialPosition.getInhomogeneousCoordinate(i);</span>
                    }
                }
<span class="fc" id="L1054">                return initial;</span>
            }

            @Override
            public double evaluate(
                    final int i, final double[] point, final double[] params, final double[] derivatives) {
<span class="fc" id="L1060">                return NonLinearFingerprintPositionEstimator.this.evaluate(i, point, params, derivatives);</span>
            }
        });

        try {
<span class="fc" id="L1065">            final var x = new Matrix(totalReadings, n);</span>
<span class="fc" id="L1066">            final var y = new double[totalReadings];</span>
<span class="fc" id="L1067">            final var standardDeviations = new double[totalReadings];</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">            for (var i = 0; i &lt; totalReadings; i++) {</span>
                // fingerprint power Pr(p1)
<span class="fc" id="L1070">                x.setElementAt(i, 0, allFingerprintPower.get(i));</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">                for (var j = 0; j &lt; dims; j++) {</span>
<span class="fc" id="L1072">                    x.setElementAt(i, j + 1, allFingerprintPositions.get(i).getInhomogeneousCoordinate(j));</span>
<span class="fc" id="L1073">                    x.setElementAt(i, j + 1 + dims, allSourcesPosition.get(i).getInhomogeneousCoordinate(j));</span>
                }
<span class="fc" id="L1075">                x.setElementAt(i, 1 + 2 * dims, allPathLossExponents.get(i));</span>

<span class="fc" id="L1077">                y[i] = allReceivedPower.get(i);</span>

<span class="fc" id="L1079">                standardDeviations[i] = allStandardDeviations.get(i);</span>
            }

<span class="fc" id="L1082">            mFitter.setInputData(x, y, standardDeviations);</span>
<span class="nc" id="L1083">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L1084">            throw new FittingException(e);</span>
<span class="fc" id="L1085">        }</span>
<span class="fc" id="L1086">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>