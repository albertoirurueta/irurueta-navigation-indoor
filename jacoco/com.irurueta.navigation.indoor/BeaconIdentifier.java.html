<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeaconIdentifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-indoor</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor</a> &gt; <span class="el_source">BeaconIdentifier.java</span></div><h1>BeaconIdentifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor;

import java.io.Serializable;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.UUID;
import java.util.regex.Pattern;

/**
 * Encapsulates a beacon identifier of arbitrary byte length.
 * It can encapsulate an identifier that is a 16-byte UUID, or an integer.
 * Based on:
 * &lt;a href=&quot;https://github.com/AltBeacon/android-beacon-library/blob/master/src/main/java/org/altbeacon/beacon/Identifier.java&quot;&gt;
 *   https://github.com/AltBeacon/android-beacon-library/blob/master/src/main/java/org/altbeacon/beacon/Identifier.java
 * &lt;/a&gt;
 */
public class BeaconIdentifier implements Comparable&lt;BeaconIdentifier&gt;, Serializable {
    /**
     * Parses beacon identifiers in hexadecimal format.
     */
<span class="fc" id="L36">    private static final Pattern HEX_PATTERN = Pattern.compile(&quot;^0x[0-9A-Fa-f]*$&quot;);</span>

    /**
     * Parses beacon identifiers in hexadecimal format without prefix.
     */
<span class="fc" id="L41">    private static final Pattern HEX_PATTERN_NO_PREFIX = Pattern.compile(&quot;^[0-9A-Fa-f]*$&quot;);</span>

    /**
     * Parses beacon identifiers in decimal format.
     */
<span class="fc" id="L46">    private static final Pattern DECIMAL_PATTERN = Pattern.compile(&quot;^(0|[1-9][0-9]*)$&quot;);</span>

    /**
     * Parses beacon identifiers in UUID format.
     */
<span class="fc" id="L51">    private static final Pattern UUID_PATTERN = Pattern.compile(</span>
            &quot;^[0-9A-Fa-f]{8}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{12}$&quot;);

    /**
     * Maximum allowed identifier value from an integer.
     */
    private static final int MAX_INTEGER = 65535;

    /**
     * Contains digits to represent this instance in hexadecimal format.
     */
<span class="fc" id="L62">    private static final char[] HEX_DIGITS =</span>
            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    /**
     * Internal value holding a beacon identifier as a byte array.
     */
    private byte[] value;


    /**
     * Empty constructor to prevent deserialization issues.
     */
<span class="fc" id="L74">    protected BeaconIdentifier() {</span>
<span class="fc" id="L75">    }</span>

    /**
     * Creates a nw instance of a beacon identifier.
     *
     * @param value value to use.
     * @throws NullPointerException if provided value is null.
     */
<span class="fc" id="L83">    protected BeaconIdentifier(final byte[] value) {</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L85">            throw new NullPointerException(</span>
                    &quot;Identifiers cannot be constructed from null pointers but \&quot;value\&quot; is null.&quot;);
        }

<span class="fc" id="L89">        this.value = value;</span>
<span class="fc" id="L90">    }</span>

    /**
     * Takes the passed string and tries to figure out what format it is in.
     * Then turns the string into plain bytes and constructs an identifier.
     * &lt;p&gt;
     * This method parses UUIDs without dashes for compatibility (although this is not a standard behaviour).
     * &lt;p&gt;
     * Allowed formats:
     * &lt;ul&gt;
     *   &lt;li&gt;UUID: 2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6 (16 bytes)&lt;/li&gt;
     *   &lt;li&gt;Hexadecimal: 0x000000000003 (variable length)&lt;/li&gt;
     *   &lt;li&gt;Decimal: 1337 (2 bytes)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param stringValue string to be parsed.
     * @return an identifier representing the specified value.
     * @throws NullPointerException     if string value is null.
     * @throws IllegalArgumentException if parsing fails for some other reason (invalid format, etc.).
     * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122 on UUIDs&lt;/a&gt;
     */
    public static BeaconIdentifier parse(final String stringValue) {
<span class="fc" id="L112">        return parse(stringValue, -1);</span>
    }

    /**
     * Variant of the parse method that allows specifying the byte length of the identifier.
     *
     * @param stringValue       value to be parsed.
     * @param desiredByteLength requested number of bytes to hold the identifier or -1 if not specified.
     * @return the parsed identifier.
     * @throws NullPointerException     if string value is null.
     * @throws IllegalArgumentException if parsing fails for some other reason (invalid format, etc.).
     */
    public static BeaconIdentifier parse(final String stringValue, final int desiredByteLength) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (stringValue == null) {</span>
<span class="fc" id="L126">            throw new NullPointerException(</span>
                    &quot;Identifiers cannot be constructed from null pointers but \&quot;stringValue\&quot; is null.&quot;);
        }

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (HEX_PATTERN.matcher(stringValue).matches()) {</span>
            // parse hexadecimal format
<span class="fc" id="L132">            return parseHex(stringValue.substring(2), desiredByteLength);</span>
        }

<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (UUID_PATTERN.matcher(stringValue).matches()) {</span>
            // parse UUID format
<span class="fc" id="L137">            return parseHex(stringValue.replace(&quot;-&quot;, &quot;&quot;), desiredByteLength);</span>
        }

<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (DECIMAL_PATTERN.matcher(stringValue).matches()) {</span>
            // parse decimal format
<span class="fc" id="L142">            var value = Integer.parseInt(stringValue);</span>
<span class="pc bpc" id="L143" title="1 of 4 branches missed.">            if (desiredByteLength &lt;= 0 || desiredByteLength == 2) {</span>
<span class="fc" id="L144">                return fromInt(value);</span>
            } else {
<span class="fc" id="L146">                return fromLong(value, desiredByteLength);</span>
            }
        }

<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (HEX_PATTERN_NO_PREFIX.matcher(stringValue).matches()) {</span>
            // parse hexadecimal format without prefix
<span class="fc" id="L152">            return parseHex(stringValue, desiredByteLength);</span>
        }

<span class="fc" id="L155">        throw new IllegalArgumentException(&quot;Unable to parse identifier&quot;);</span>
    }

    /**
     * Creates an identifier backed by an array of length desiredByteLength.
     *
     * @param longValue         a long to put into the identifier.
     * @param desiredByteLength how many bytes to make the identifier.
     * @return the parsed identifier.
     * @throws IllegalArgumentException if desired number of bytes is negative.
     */
    public static BeaconIdentifier fromLong(long longValue, final int desiredByteLength) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (desiredByteLength &lt; 0) {</span>
<span class="fc" id="L168">            throw new IllegalArgumentException(&quot;identifier length must be &gt; 0&quot;);</span>
        }
<span class="fc" id="L170">        final var newValue = new byte[desiredByteLength];</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (var i = desiredByteLength - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L172">            newValue[i] = (byte) (longValue &amp; 0xff);</span>
<span class="fc" id="L173">            longValue = longValue &gt;&gt; 8;</span>
        }
<span class="fc" id="L175">        return new BeaconIdentifier(newValue);</span>
    }

    /**
     * Creates an identifier backed by a two byte array (big endian).
     *
     * @param intValue an integer between 0 and 65535 (inclusive).
     * @return an identifier with the specified value.
     * @throws IllegalArgumentException if provided value is out of valid range (from 0 to 65535).
     */
    public static BeaconIdentifier fromInt(final int intValue) {
<span class="fc bfc" id="L186" title="All 4 branches covered.">        if (intValue &lt; 0 || intValue &gt; MAX_INTEGER) {</span>
<span class="fc" id="L187">            throw new IllegalArgumentException(</span>
                    &quot;Identifiers can only be constructed from integers between 0 and &quot; + MAX_INTEGER + &quot; (inclusive).&quot;);
        }

<span class="fc" id="L191">        final var newValue = new byte[2];</span>

<span class="fc" id="L193">        newValue[0] = (byte) (intValue &gt;&gt; 8);</span>
<span class="fc" id="L194">        newValue[1] = (byte) (intValue);</span>

<span class="fc" id="L196">        return new BeaconIdentifier(newValue);</span>
    }

    /**
     * Creates an identifier from the specified byte array.
     *
     * @param bytes        array to copy from.
     * @param start        the start index, inclusive.
     * @param end          the end index, exclusive.
     * @param littleEndian whether the bytes are ordered in little endian.
     * @return a new identifier.
     * @throws NullPointerException           if bytes is null.
     * @throws ArrayIndexOutOfBoundsException if start or end are outside the bounds of the array.
     * @throws IllegalArgumentException       start is larger than end.
     */
    public static BeaconIdentifier fromBytes(
            final byte[] bytes, final int start, final int end, final boolean littleEndian) {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (bytes == null) {</span>
<span class="fc" id="L214">            throw new NullPointerException(</span>
                    &quot;Identifiers cannot be constructed from null pointers but \&quot;bytes\&quot; is null.&quot;);
        }
<span class="pc bpc" id="L217" title="1 of 4 branches missed.">        if (start &lt; 0 || start &gt; bytes.length) {</span>
<span class="fc" id="L218">            throw new ArrayIndexOutOfBoundsException(&quot;start &lt; 0 || start &gt; bytes.length&quot;);</span>
        }
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (end &gt; bytes.length) {</span>
<span class="fc" id="L221">            throw new ArrayIndexOutOfBoundsException(&quot;end &gt; bytes.length&quot;);</span>
        }
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (start &gt; end) {</span>
<span class="fc" id="L224">            throw new IllegalArgumentException(&quot;start &gt; end&quot;);</span>
        }

<span class="fc" id="L227">        final var byteRange = Arrays.copyOfRange(bytes, start, end);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (littleEndian) {</span>
<span class="fc" id="L229">            reverseArray(byteRange);</span>
        }
<span class="fc" id="L231">        return new BeaconIdentifier(byteRange);</span>
    }

    /**
     * Transforms a {@link UUID} into an identifier.
     * No mangling with strings, only the underlying bytes of the
     * UUID are used so this is fast and stable.
     *
     * @param uuid UUID to create identifier from.
     * @return a new identifier.
     */
    public static BeaconIdentifier fromUuid(final UUID uuid) {
<span class="fc" id="L243">        final var buf = ByteBuffer.allocate(16);</span>
<span class="fc" id="L244">        buf.putLong(uuid.getMostSignificantBits());</span>
<span class="fc" id="L245">        buf.putLong(uuid.getLeastSignificantBits());</span>
<span class="fc" id="L246">        return new BeaconIdentifier(buf.array());</span>
    }

    /**
     * Represents the value as a String. The output varies based on the length of the value.
     * &lt;ul&gt;&lt;li&gt;When the value is 2 bytes long: decimal, for example 6536.
     * &lt;li&gt;When the value is 16 bytes long: uuid, for example 2f234454-cf6d-4a0f-adf2-f4911ba9ffa6
     * &lt;li&gt;Else: hexadecimal prefixed with &lt;code&gt;0x&lt;/code&gt;, for example 0x0012ab&lt;/ul&gt;
     *
     * @return string representation of the current value.
     */
    @Override
    public String toString() {
        // Note:  the toString() method is also used for serialization and deserialization.  So
        // toString() and parse() must always return objects that return true when you call equals()
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L262">            return super.toString();</span>
        }

<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (value.length == 2) {</span>
<span class="fc" id="L266">            return Integer.toString(toInt());</span>
        }
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (value.length == 16) {</span>
<span class="fc" id="L269">            return toUuid().toString();</span>
        }
<span class="fc" id="L271">        return toHexString();</span>
    }

    /**
     * Represents the value as an &lt;code&gt;int&lt;/code&gt;.
     *
     * @return value represented as int.
     * @throws UnsupportedOperationException when value length is longer than 2.
     */
    public int toInt() {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L282">            return 0;</span>
        }

<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (value.length &gt; 2) {</span>
<span class="fc" id="L286">            throw new UnsupportedOperationException(&quot;Only supported for Identifiers with max byte length of 2&quot;);</span>
        }

<span class="fc" id="L289">        var result = 0;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (var i = 0; i &lt; value.length; i++) {</span>
<span class="fc" id="L291">            result |= (value[i] &amp; 0xFF) &lt;&lt; ((value.length - i - 1) * 8);</span>
        }

<span class="fc" id="L294">        return result;</span>
    }

    /**
     * Converts identifier to a byte array.
     *
     * @param bigEndian true if bytes are MSB first.
     * @return a new byte array with a copy of the value.
     */
    public byte[] toByteArrayOfSpecifiedEndianness(final boolean bigEndian) {
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L305">            return null;</span>
        }

<span class="fc" id="L308">        final var copy = Arrays.copyOf(value, value.length);</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (!bigEndian) {</span>
<span class="fc" id="L311">            reverseArray(copy);</span>
        }

<span class="fc" id="L314">        return copy;</span>
    }

    /**
     * Returns the byte length of this identifier.
     *
     * @return length of identifier.
     */
    public int getByteCount() {
<span class="fc bfc" id="L323" title="All 2 branches covered.">        return value != null ? value.length : 0;</span>
    }

    /**
     * Represents the value as a hexadecimal String. The String is prefixed with &lt;code&gt;0x&lt;/code&gt;. For example
     * 0x0034ab.
     *
     * @return value as hexadecimal String.
     */
    public String toHexString() {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L334">            return null;</span>
        }

<span class="fc" id="L337">        final var l = value.length;</span>
<span class="fc" id="L338">        final var out = new char[l * 2 + 2];</span>
<span class="fc" id="L339">        out[0] = '0';</span>
<span class="fc" id="L340">        out[1] = 'x';</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">        for (int i = 0, j = 2; i &lt; l; i++) {</span>
<span class="fc" id="L342">            out[j] = HEX_DIGITS[(0xF0 &amp; value[i]) &gt;&gt;&gt; 4];</span>
<span class="fc" id="L343">            j++;</span>
<span class="fc" id="L344">            out[j] = HEX_DIGITS[0x0F &amp; value[i]];</span>
<span class="fc" id="L345">            j++;</span>
        }
<span class="fc" id="L347">        return new String(out);</span>
    }

    /**
     * Gives you the identifier as a UUID if possible.
     *
     * @return the identifier as a UUID.
     * @throws UnsupportedOperationException if conversion to UUID fails.
     */
    public UUID toUuid() {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L358">            return null;</span>
        }

<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (value.length != 16) {</span>
<span class="fc" id="L362">            throw new UnsupportedOperationException(&quot;Only Identifiers backed by a byte array with length of exactly 16 can be UUIDs.&quot;);</span>
        }
<span class="fc" id="L364">        final var buf = ByteBuffer.wrap(value).asLongBuffer();</span>
<span class="fc" id="L365">        return new UUID(buf.get(), buf.get());</span>
    }

    /**
     * Gives you the byte array backing this identifier. Note that identifiers are immutable,
     * so changing that the returned array will not result in a changed identifier.
     *
     * @return a deep copy of the data backing this identifier.
     */
    public byte[] toByteArray() {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        return value != null ? value.clone() : null;</span>
    }

    /**
     * Computes hash code for this instance.
     *
     * @return this instance hash code.
     */
    @Override
    public int hashCode() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        return value != null ? Arrays.hashCode(value) : 0;</span>
    }

    /**
     * Returns whether both identifiers contain equal value.
     * This is the case when the value is the same and has the same length.
     *
     * @param that object to compare to.
     * @return whether that equals this.
     */
    @Override
    public boolean equals(final Object that) {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (!(that instanceof BeaconIdentifier thatIdentifier)) {</span>
<span class="nc" id="L398">            return false;</span>
        }
<span class="fc" id="L400">        return Arrays.equals(value, thatIdentifier.value);</span>
    }

    /**
     * Compares two identifiers.
     * When the identifiers don't have the same length, the identifier having the shortest
     * array is considered smaller than the other.
     *
     * @param that the other identifier.
     * @return 0 if both identifiers are equal. Otherwise, returns -1 or 1 depending on
     * which is bigger than th other.
     * @see Comparable#compareTo(Object)
     */
    @Override
    public int compareTo(final BeaconIdentifier that) {
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (value.length != that.value.length) {</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            return value.length &lt; that.value.length ? -1 : 1;</span>
        }
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (var i = 0; i &lt; value.length; i++) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (value[i] != that.value[i]) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">                return value[i] &lt; that.value[i] ? -1 : 1;</span>
            }
        }
<span class="fc" id="L423">        return 0;</span>
    }

    /**
     * Reverses provided array.
     *
     * @param bytes array to be reversed.
     */
    private static void reverseArray(final byte[] bytes) {
<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (var i = 0; i &lt; bytes.length / 2; i++) {</span>
<span class="fc" id="L433">            final var mirroredIndex = bytes.length - i - 1;</span>
<span class="fc" id="L434">            final var tmp = bytes[i];</span>
<span class="fc" id="L435">            bytes[i] = bytes[mirroredIndex];</span>
<span class="fc" id="L436">            bytes[mirroredIndex] = tmp;</span>
        }
<span class="fc" id="L438">    }</span>

    /**
     * Parses a string containing a beacon identifier in hexadecimal format.
     *
     * @param identifierString  string to be parsed.
     * @param desiredByteLength length of byte array to create to hold provided value.
     * @return the parsed identifier.
     */
    private static BeaconIdentifier parseHex(final String identifierString, final int desiredByteLength) {
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        var str = identifierString.length() % 2 == 0 ? &quot;&quot; : &quot;0&quot;;</span>
<span class="fc" id="L449">        str += identifierString.toUpperCase();</span>
<span class="fc" id="L450">        var len = str.length();</span>

<span class="fc bfc" id="L452" title="All 4 branches covered.">        if (desiredByteLength &gt; 0 &amp;&amp; desiredByteLength &lt; len / 2) {</span>
<span class="fc" id="L453">            str = str.substring(len - desiredByteLength * 2);</span>
<span class="fc" id="L454">            len = str.length();</span>
        }
<span class="fc bfc" id="L456" title="All 4 branches covered.">        if (desiredByteLength &gt; 0 &amp;&amp; desiredByteLength &gt; len / 2) {</span>
<span class="fc" id="L457">            final var extraCharsToAdd = desiredByteLength * 2 - len;</span>
<span class="fc" id="L458">            final var sb = new StringBuilder();</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            while (sb.length() &lt; extraCharsToAdd) {</span>
<span class="fc" id="L460">                sb.append(&quot;0&quot;);</span>
            }
<span class="fc" id="L462">            str = sb + str;</span>
<span class="fc" id="L463">            len = str.length();</span>
        }

<span class="fc" id="L466">        final var result = new byte[len / 2];</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">        for (var i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L468">            result[i] = (byte) (Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16) &amp; 0xFF);</span>
        }
<span class="fc" id="L470">        return new BeaconIdentifier(result);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>