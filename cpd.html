<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from org.apache.maven.plugins:maven-pmd-plugin:3.27.0:cpd at 2025-12-18
 | Rendered using Apache Maven Fluido Skin 2.0.0-M9
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>CPD Results â€“ com.irurueta:irurueta-navigation-indoor</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M9.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M9.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>com.irurueta:irurueta-navigation-indoor</h1></div></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2025-12-18<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.5.0-SNAPSHOT</li>
        <li class="pull-right"><a href="./">com.irurueta:irurueta-navigation-indoor</a></li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-down"></span>Project Reports</a>
     <ul class="nav nav-list">
      <li><a href="apidocs/index.html">Javadoc</a></li>
      <li><a href="testapidocs/index.html">Test Javadoc</a></li>
      <li><a href="surefire.html">Surefire</a></li>
      <li><a href="checkstyle.html">Checkstyle</a></li>
      <li><a href="spotbugs.html">SpotBugs</a></li>
      <li class="active"><a>CPD</a></li>
      <li><a href="pmd.html">PMD</a></li>
      <li><a href="xref/index.html">Source Xref</a></li>
      <li><a href="xref-test/index.html">Test Source Xref</a></li>
     </ul></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="CPD_Results"></a>
<h1>CPD Results</h1>
<p>The following document contains the results of PMD's  <a class="externalLink" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html">CPD</a> 7.14.0.</p><section><a id="Duplications"></a>
<h2>Duplications</h2>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L706">706</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L687">687</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final SequentialRobustMixedPositionEstimatorListener&lt;P&gt; listener) {
        this(sourceQualityScores, fingerprintReadingQualityScores, sources, fingerprint);
        this.listener = listener;
    }

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation using ranging data.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
        return rangingRobustMethod;
    }

    /**
     * Sets robust method for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod robust method used for robust position estimation
     *                            using ranging data.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingRobustMethod(final RobustEstimatorMethod rangingRobustMethod) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.rangingRobustMethod = rangingRobustMethod;
    }

    /**
     * Gets robust method used for coarse robust position estimation using RSSI data.
     *
     * @return robust method used for coarse robust position estimation using RSSI
     * data.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
        return rssiRobustMethod;
    }

    /**
     * Sets robust method used for coarse robust position estimation using RSSI data.
     *
     * @param rssiRobustMethod robust method used for coarse robust position estimation
     *                         using RSSI data.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiRobustMethod(final RobustEstimatorMethod rssiRobustMethod) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.rssiRobustMethod = rssiRobustMethod;
    }

    /**
     * Indicates whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for ranging measurements.
     *
     * @return true to take into account radio source position covariance during ranging
     * position estimation, false otherwise.
     */
    public boolean isRangingRadioSourcePositionCovarianceUsed() {
        return useRangingRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for ranging measurements.
     *
     * @param useRangingRadioSourcePositionCovariance true to take into account radio
     *                                                source position covariance during
     *                                                ranging position estimation,
     *                                                false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingRadioSourcePositionCovarianceUsed(
            final boolean useRangingRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.useRangingRadioSourcePositionCovariance =
                useRangingRadioSourcePositionCovariance;
    }

    /**
     * Indicates whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for RSSI measurements.
     *
     * @return true to take into account radio source position covariance during RSSI
     * position estimation, false otherwise.
     */
    public boolean isRssiRadioSourcePositionCovarianceUsed() {
        return useRssiRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for RSSI measurements.
     *
     * @param useRssiRadioSourcePositionCovariance true to take into account radio
     *                                             source position covariance during
     *                                             RSSI position estimation, false
     *                                             otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiRadioSourcePositionCovarianceUsed(final boolean useRssiRadioSourcePositionCovariance)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.useRssiRadioSourcePositionCovariance = useRssiRadioSourcePositionCovariance;
    }

    /**
     * Indicates whether ranging readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     *
     * @return true if ranging readings are evenly distributed among radio sources,
     * false otherwise.
     */
    public boolean isRangingReadingsEvenlyDistributed() {
        return evenlyDistributeRangingReadings;
    }

    /**
     * Specifies whether ranging readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     *
     * @param evenlyDistributeRangingReadings true if ranging readings are evenly
     *                                        distributed among radio sources, false
     *                                        otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingReadingsEvenlyDistributed(final boolean evenlyDistributeRangingReadings)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.evenlyDistributeRangingReadings = evenlyDistributeRangingReadings;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     *
     * @return distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     */
    public double getRssiFallbackDistanceStandardDeviation() {
        return rssiFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     *
     * @param rssiFallbackDistanceStandardDeviation distance standard deviation fallback
     *                                              value to use when none can be
     *                                              determined from provided RSSI
     *                                              measurements.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiFallbackDistanceStandardDeviation(final double rssiFallbackDistanceStandardDeviation)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rssiFallbackDistanceStandardDeviation = rssiFallbackDistanceStandardDeviation;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     *
     * @return distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     */
    public double getRangingFallbackDistanceStandardDeviation() {
        return rangingFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     *
     * @param rangingFallbackDistanceStandardDeviation distance standard deviation
     *                                                 fallback value to use when none
     *                                                 can be determined from provided
     *                                                 ranging measurements.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingFallbackDistanceStandardDeviation(final double rangingFallbackDistanceStandardDeviation)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rangingFallbackDistanceStandardDeviation = rangingFallbackDistanceStandardDeviation;
    }

    /**
     * Indicates whether RSSI readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     *
     * @return true if RSSI readings are evenly distributed among radio sources,
     * false otherwise.
     */
    public boolean isRssiReadingsEvenlyDistributed() {
        return evenlyDistributeRssiReadings;
    }

    /**
     * Specifies whether RSSI readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     *
     * @param evenlyDistributeRssiReadings true if RSSI readings are evenly distributed
     *                                     among radio sources, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiReadingsEvenlyDistributed(final boolean evenlyDistributeRssiReadings) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.evenlyDistributeRssiReadings = evenlyDistributeRssiReadings;
    }

    /**
     * Gets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this instance is locked.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%) for robust position estimation on ranging data. The
     * amount of confidence indicates the probability that the estimated result is
     * correct. Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return rangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(final double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return rssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence amount of confidence for robust position estimation as
     *                       a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(final double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return rangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set for
     *                             position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(final int rangingMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return rssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(final int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return refineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(final boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.refineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return keepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(final boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.keepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {
        return useRangingLinearSolver;
    }

    /**
     * Specifies whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @param useRangingLinearSolver true if a linear solver is used for preliminary
     *                               solution estimation on ranging readings.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingLinearSolverUsed(final boolean useRangingLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useRangingLinearSolver = useRangingLinearSolver;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * RSSI readings.
     */
    public boolean isRssiLinearSolverUsed() {
        return useRssiLinearSolver;
    }

    /**
     * Specifies whether a linear solver is used for preliminary solution estimation
     * using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @param useRssiLinearSolver true if a linear solver is used for preliminary
     *                            solution estimation on RSSI readings.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiLinearSolverUsed(final boolean useRssiLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useRssiLinearSolver = useRssiLinearSolver;
    }

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the ranging fine estimation.
     *
     * @return true to use an homogeneous linear solver for preliminary solutions
     * during ranging fine position estimation.
     */
    public boolean isRangingHomogeneousLinearSolverUsed() {
        return useRangingHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the ranging fine estimation.
     *
     * @param useRangingHomogeneousLinearSolver true to use an homogeneous linear
     *                                          solver for preliminary solutions during
     *                                          ranging fine position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingHomogeneousLinearSolverUsed(final boolean useRangingHomogeneousLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useRangingHomogeneousLinearSolver = useRangingHomogeneousLinearSolver;
    }

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the RSSI coarse estimation.
     *
     * @return true to use an homogeneous linear solver for preliminary solutions
     * during RSSI coarse position estimation.
     */
    public boolean isRssiHomogeneousLinearSolverUsed() {
        return useRssiHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the RSSI coarse estimation.
     *
     * @param useRssiHomogeneousLinearSolver true to use an homogeneous linear
     *                                       solver for preliminary solutions during
     *                                       RSSI fine position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiHomogeneousLinearSolverUsed(final boolean useRssiHomogeneousLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useRssiHomogeneousLinearSolver = useRssiHomogeneousLinearSolver;
    }

    /**
     * Indicates whether preliminary ranging solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non-linear
     * solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @return true if preliminary ranging solutions must be refined after an initial
     * linear solution, false otherwise.
     */
    public boolean isRangingPreliminarySolutionRefined() {
        return refineRangingPreliminarySolutions;
    }

    /**
     * Specifies whether preliminary ranging solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non-linear
     * solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @param refineRangingPreliminarySolutions true if preliminary ranging solutions
     *                                          must be refined after an initial linear
     *                                          solution, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingPreliminarySolutionRefined(final boolean refineRangingPreliminarySolutions)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.refineRangingPreliminarySolutions = refineRangingPreliminarySolutions;
    }

    /**
     * Indicates whether preliminary RSSI solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non-linear
     * solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @return true if preliminary RSSI solutions must be refined after an initial
     * linear solution, false otherwise.
     */
    public boolean isRssiPreliminarySolutionRefined() {
        return refineRssiPreliminarySolutions;
    }

    /**
     * Specifies whether preliminary RSSI solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non-linear
     * solver will be used regardless of this value using an average solution
     * as the initial value ot be refined.
     *
     * @param refineRssiPreliminarySolutions true if preliminary RSSI solutions must
     *                                       be refined after an initial linear
     *                                       solution, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiPreliminarySolutionRefined(final boolean refineRssiPreliminarySolutions) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.refineRssiPreliminarySolutions = refineRssiPreliminarySolutions;
    }

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
        return rangingPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize size of subsets to be checked during
     *                                     ranging robust estimation.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setRangingPreliminarySubsetSize(final int rangingPreliminarySubsetSize) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingPreliminarySubsetSize &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.rangingPreliminarySubsetSize = rangingPreliminarySubsetSize;
    }

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
        return rssiPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setRssiPreliminarySubsetSize(final int rssiPreliminarySubsetSize) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiPreliminarySubsetSize &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.rssiPreliminarySubsetSize = rssiPreliminarySubsetSize;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * fine ranging position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
        return rangingThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * fine ranging position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(final Double rangingThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rangingThreshold = rangingThreshold;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * coarse RSSI position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
        return rssiThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * coarse RSSI position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(final Double rssiThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rssiThreshold = rssiThreshold;
    }

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;RadioSourceLocated&lt;P&gt;&gt; getSources() {
        //noinspection unchecked
        return (List&lt;RadioSourceLocated&lt;P&gt;&gt;) sources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    public void setSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt; getFingerprint() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1099">1099</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1087">1087</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final SequentialRobustMixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether estimator is locked during estimation.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException          if this estimator is locked.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
        return rangingRobustMethod;
    }

    /**
     * Sets robust method used for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod robust method used for robust position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingRobustMethod(final RobustEstimatorMethod rangingRobustMethod) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rangingRobustMethod = rangingRobustMethod;
    }

    /**
     * Gets robust method used for path-loss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @return robust method used for path-loss exponent and transmitted power
     * estimation.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
        return rssiRobustMethod;
    }

    /**
     * Sets robust method used for path-loss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @param rssiRobustMethod robust method used for path-loss exponent and transmitted
     *                         power estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiRobustMethod(final RobustEstimatorMethod rssiRobustMethod) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rssiRobustMethod = rssiRobustMethod;
    }

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
        return rangingPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize size of subsets to be checked during
     *                                     ranging robust estimation.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRangingPreliminarySubsetSize(final int rangingPreliminarySubsetSize) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingPreliminarySubsetSize &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        this.rangingPreliminarySubsetSize = rangingPreliminarySubsetSize;
    }

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
        return rssiPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRssiPreliminarySubsetSize(final int rssiPreliminarySubsetSize) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiPreliminarySubsetSize &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        this.rssiPreliminarySubsetSize = rssiPreliminarySubsetSize;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
        return rangingThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(final Double rangingThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rangingThreshold = rangingThreshold;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * path-loss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
        return rssiThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * path-loss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(final Double rssiThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rssiThreshold = rssiThreshold;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for robust position estimation. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value
     * between 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return rangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation. The amount of confidence
     * indicates the probability that the estimated result is correct. Usually this
     * value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation
     *                          as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(final double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for path-loss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust path-loss exponent and transmitted power
     * estimation as a value between 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return rssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for path-loss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct. Usually this value will be close to 10.0, but
     * not exactly 1.0.
     *
     * @param rssiConfidence confidence to be set for robust path-loss exponent and
     *                       transmitted power estimation as a value between 0.0 and
     *                       1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(final double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rssiConfidence = rssiConfidence;
    }

    /**
     * Returns maximum allowed number of iterations for robust position estimation. If
     * maximum allowed number of iterations is achieved without converging to a result
     * when calling estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return rangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust position estimation. When
     * the maximum number of iterations is exceeded, an approximate result might be
     * available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set
     *                             for position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked.
     */
    public void setRangingMaxIterations(final int rangingMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Returns maximum allowed number of iterations for robust path-loss exponent and
     * transmitted power estimation. If maximum allowed number of iterations is achieved
     * without converging to a result when calling estimate(), a RobustEstimatorException
     * will be raised.
     *
     * @return maximum allowed number of iterations for path-loss exponent and transmitted
     * power estimation.
     */
    public int getRssiMaxIterations() {
        return rssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust path-loss exponent and
     * transmitted power estimation. When the maximum number of iterations is exceeded,
     * an approximate result might be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          path-loss exponent and transmitted power estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked.
     */
    public void setRssiMaxIterations(final int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
        return refineResult;
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if estimator is locked.
     */
    public void setResultRefined(final boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.refineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return keepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(final boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.keepCovariance = keepCovariance;
    }

    /**
     * Gets signal readings belonging to the same radio source.
     *
     * @return signal readings belonging to the same radio source.
     */
    public List&lt;ReadingLocated&lt;P&gt;&gt; getReadings() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1525">1525</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1513">1513</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public void setListener(final SequentialRobustMixedRadioSourceEstimatorListener&lt;S, P&gt; listener)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.listener = listener;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return initialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return initialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(final double initialPathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return transmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(final boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.transmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     *
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return pathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     *
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(final boolean pathLossEstimationEnabled) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.pathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return useReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(final boolean useReadingPositionCovariances) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @return true if homogeneous ranging linear solver is used, false if an inhomogeneous ranging linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
        return useHomogeneousRangingLinearSolver;
    }

    /**
     * Specifies whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @param useHomogeneousRangingLinearSolver true if homogeneous ranging linear solver is used, false
     *                                          if an inhomogeneous ranging linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(final boolean useHomogeneousRangingLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.useHomogeneousRangingLinearSolver = useHomogeneousRangingLinearSolver;
    }


    /**
     * Gets covariance for estimated position and power.
     * Matrix contains information in the following order:
     * Top-left sub-matrix contains covariance of position,
     * then follows transmitted power variance, and finally
     * the last element contains path-loss exponent variance.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return covariance for estimated position and power.
     */
    public Matrix getCovariance() {
        return covariance;
    }

    /**
     * Gets estimated position covariance.
     * Size of this matrix will depend on the number of dimensions
     * of estimated position (either 2 or 3).
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated position covariance.
     */
    public Matrix getEstimatedPositionCovariance() {
        return estimatedPositionCovariance;
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public P getEstimatedPosition() {
        return estimatedPosition;
    }

    /**
     * Indicates whether readings are valid or not.
     * Readings are considered valid when there are enough readings.
     *
     * @param readings readings to be validated.
     * @return true if readings are valid, false otherwise.
     */
    public boolean areValidReadings(final List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L482">482</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1143">1143</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(
            final double fingerprintRssi, final double pathLossExponent, final Point3D fingerprintPosition,
            final Point3D radioSourcePosition, final Point3D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 3D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //   - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();
        final var z1 = fingerprintPosition.getInhomZ();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();
        final var za = radioSourcePosition.getInhomZ();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();
        final var zi = estimatedPosition.getInhomZ();

        final var mean = new double[]{
                fingerprintRssi, pathLossExponent, x1, y1, z1, xa, ya, za, xi, yi, zi
        };
        final var covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2, 4, 4,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null
                &amp;&amp; radioSourcePositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; radioSourcePositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(5, 5, 7, 7,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null
                &amp;&amp; estimatedPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; estimatedPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(8, 8, 10, 10,
                    estimatedPositionCovariance);
        }

        try {
            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(final double[] x, final double[] y, final Matrix jacobian) {

                    // Pr(pi) = Pr(p1)
                    //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    //   - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
                    // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                    // Hence:
                    // Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1) + (z1 - za)*(zi - z1))/
                    //       (ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                    final var diffX1a = x1 - xa;
                    final var diffY1a = y1 - ya;
                    final var diffZ1a = z1 - za;

                    final var diffXi1 = xi - x1;
                    final var diffYi1 = yi - y1;
                    final var diffZi1 = zi - z1;

                    final var diffX1a2 = diffX1a * diffX1a;
                    final var diffY1a2 = diffY1a * diffY1a;
                    final var diffZ1a2 = diffZ1a * diffZ1a;

                    final var d1a2 = diffX1a2 + diffY1a2 + diffZ1a2;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L808">808</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L801">801</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

            @Override
            public double[] getQualityScores() {
                return qualityScores;
            }

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return PROSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionAndRadioSourceEstimator.html#L166">166</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionEstimator.html#L168">168</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected BaseFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final L listener) {
        this(listener);
        internalSetLocatedFingerprints(locatedFingerprints);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets located fingerprints containing RSSI readings.
     *
     * @return located fingerprints containing RSSI readings.
     */
    public List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt; getLocatedFingerprints() {
        //noinspection unchecked
        return (List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;,P&gt;&gt;) locatedFingerprints;
    }

    /**
     * Sets located fingerprints containing RSSI readings.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or there are not enough
     *                                  fingerprints or readings within provided fingerprints (for 2D position estimation at
     *                                  least 2 readings are required in a single fingerprint, or at least 2 fingerprints
     *                                  at different locations containing a single reading are required. For 3D position
     *                                  estimation 3 reading in a single fingerprint, or 3 fingerprints containing a single
     *                                  reading or any combination resulting in at least 3 readings at different locations
     *                                  are required).
     */
    public void setLocatedFingerprints(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetLocatedFingerprints(locatedFingerprints);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * fingerprints.
     *
     * @return fingerprint containing readings at an unknown location for provided located
     * fingerprints.
     */
    public RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt; getFingerprint() {
        //noinspection unchecked
        return (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) fingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located fingerprints.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for provided located fingerprints.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(
            final RssiFingerprint&lt;? extends RadioSource, ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Get minimum number of nearest fingerprints to search.
     *
     * @return minimum number of nearest fingerprints, -1 indicates to initially use
     * all fingerprints needed to estimate available radio sources.
     */
    public int getMinNearestFingerprints() {
        return minNearestFingerprints;
    }

    /**
     * Gets maximum number of nearest fingerprints to search.
     *
     * @return maximum number of nearest fingerprints, -1 indicates to use all available
     * fingerprints.
     */
    public int getMaxNearestFingerprints() {
        return maxNearestFingerprints;
    }

    /**
     * Sets minimum and maximum number of nearest fingerprints to search.
     * If minimum value is -1, then the minimum required number of fingerprints needed
     * to estimate available radio sources is used.
     * If maximum value is -1, then the problem is attempted to be solved until all
     * available fingerprints are used.
     *
     * @param minNearestFingerprints minimum number of nearest fingerprints or -1.
     * @param maxNearestFingerprints maximum number of nearest fingerprints or -1.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if minimum value is larger than maximum value (as
     *                                  long as it has a limit defined), or if maximum value is not negative when
     *                                  minimum one is less than 1, or if minimum value is zero.
     */
    public void setMinMaxNearestFingerprints(
            final int minNearestFingerprints, final int maxNearestFingerprints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetMinMaxNearestFingerprints(minNearestFingerprints, maxNearestFingerprints);
    }

    /**
     * Gets path loss exponent to be used by default.
     * This is typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * @return path loss exponent to be used by default.
     */
    public double getPathLossExponent() {
        return pathLossExponent;
    }

    /**
     * Sets path loss exponent to be used by default.
     * This is typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * @param pathLossExponent path loss exponent to be used by default.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossExponent(final double pathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.pathLossExponent = pathLossExponent;
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
        return listener;
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     *
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(final L listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.listener = listener;
    }

    /**
     * Gets estimated inhomogeneous position coordinates.
     *
     * @return estimated inhomogeneous position coordinates.
     */
    public double[] getEstimatedPositionCoordinates() {
        return estimatedPositionCoordinates;
    }

    /**
     * Gets estimated position and stores result into provided instance.
     *
     * @param estimatedPosition instance where estimated position will be stored.
     */
    public void getEstimatedPosition(final P estimatedPosition) {
        if (estimatedPositionCoordinates != null) {
            for (var i = 0; i &lt; estimatedPositionCoordinates.length; i++) {
                estimatedPosition.setInhomogeneousCoordinate(i, estimatedPositionCoordinates[i]);
            }
        }
    }

    /**
     * Gets estimated position or null if not available yet.
     *
     * @return estimated position or null.
     */
    public P getEstimatedPosition() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L256">256</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L756">756</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear2D(
            final double fingerprintRssi, final double pathLossExponent, final Point2D fingerprintPosition,
            final Point2D radioSourcePosition, final Point2D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 2D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();

        final var mean = new double[]{
                fingerprintRssi, pathLossExponent, x1, y1, xa, ya, xi, yi
        };
        final var covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null
                &amp;&amp; fingerprintPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; fingerprintPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2, 3, 3,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null
                &amp;&amp; radioSourcePositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; radioSourcePositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(4, 4, 5, 5,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null
                &amp;&amp; estimatedPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; estimatedPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(6, 6, 7, 7,
                    estimatedPositionCovariance);
        }

        try {
            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(final double[] x, final double[] y, final Matrix jacobian) {

                    // Pr(pi) = Pr(p1)
                    //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                    // Hence:
                    // Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/
                    //       (ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                    final var diffX1a = x1 - xa;
                    final var diffY1a = y1 - ya;

                    final var diffXi1 = xi - x1;
                    final var diffYi1 = yi - y1;

                    final var diffX1a2 = diffX1a * diffX1a;
                    final var diffY1a2 = diffY1a * diffY1a;

                    final var d1a2 = diffX1a2 + diffY1a2;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L505">505</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L496">496</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return transmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(final boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.transmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided readings will be used.
     * &lt;p&gt;
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return initialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * &lt;p&gt;
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return initialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(final double initialPathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     *
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return pathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     *
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(final boolean pathLossEstimationEnabled) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.pathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return useReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(final boolean useReadingPositionCovariances) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     *
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
        return useHomogeneousRangingLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(final boolean useHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        useHomogeneousRangingLinearSolver = useHomogeneousLinearSolver;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2451">2451</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2453">2453</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected void attemptRefine(final Solution&lt;Point2D&gt; result) {
        final var initialPosition = result.getEstimatedPosition();
        final var initialTransmittedPowerdBm = result.getEstimatedTransmittedPowerdBm();
        final var initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (refineResult &amp;&amp; inliersData != null) {
            final var inliers = inliersData.getInliers();
            final var nSamples = readings.size();

            innerReadings.clear();

            for (var i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    // sample is inlier
                    innerReadings.add(readings.get(i));
                }
            }

            try {
                innerEstimator.setInitialPosition(initialPosition);
                innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                innerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
                innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);
                innerEstimator.setReadings(innerReadings);
                innerEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);

                innerEstimator.estimate();

                final var cov = innerEstimator.getEstimatedCovariance();
                if (keepCovariance &amp;&amp; cov != null) {
                    // keep covariance
                    covariance = cov;

                    final var dims = getNumberOfDimensions();
                    var pos = 0;

                    final var d = dims - 1;
                    if (estimatedPositionCovariance == null) {
                        estimatedPositionCovariance = covariance.getSubmatrix(0, 0, d, d);
                    } else {
                        covariance.getSubmatrix(0, 0, d, d, estimatedPositionCovariance);
                    }
                    pos += dims;

                    if (transmittedPowerEstimationEnabled) {
                        // transmitted power estimation enabled
                        estimatedTransmittedPowerVariance = covariance.getElementAt(pos, pos);
                        pos++;
                    } else {
                        // transmitted power estimation disabled
                        estimatedTransmittedPowerVariance = null;
                    }

                    if (pathLossEstimationEnabled) {
                        // path-loss exponent estimation enabled
                        estimatedPathLossExponentVariance = covariance.getElementAt(pos, pos);
                    } else {
                        // path-loss exponent estimation disabled
                        estimatedPathLossExponentVariance = null;
                    }
                } else {
                    covariance = null;
                    estimatedPositionCovariance = null;
                    estimatedTransmittedPowerVariance = null;
                    estimatedPathLossExponentVariance = null;
                }

                estimatedPosition = innerEstimator.getEstimatedPosition();
                estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
                estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            } catch (final Exception e) {
                // refinement failed, so we return input value, and covariance
                // becomes unavailable
                covariance = null;
                estimatedPositionCovariance = null;
                estimatedTransmittedPowerVariance = null;
                estimatedPathLossExponentVariance = null;

                estimatedPosition = initialPosition;
                estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                estimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            covariance = null;
            estimatedPositionCovariance = null;
            estimatedTransmittedPowerVariance = null;
            estimatedPathLossExponentVariance = null;

            estimatedPosition = initialPosition;
            estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            estimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L482">482</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2074">2074</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(
            final double fingerprintRssi, final double pathLossExponent, final Point3D fingerprintPosition,
            final Point3D radioSourcePosition, final Point3D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 3D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //   - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();
        final var z1 = fingerprintPosition.getInhomZ();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();
        final var za = radioSourcePosition.getInhomZ();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();
        final var zi = estimatedPosition.getInhomZ();

        final var mean = new double[]{
                fingerprintRssi, pathLossExponent, x1, y1, z1, xa, ya, za, xi, yi, zi
        };
        final var covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2, 4, 4,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null
                &amp;&amp; radioSourcePositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; radioSourcePositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(5, 5, 7, 7,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null
                &amp;&amp; estimatedPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; estimatedPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(8, 8, 10, 10,
                    estimatedPositionCovariance);
        }

        try {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L367">367</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROSACRobustLateration2DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROSACRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L806">806</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L808">808</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return qualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return stopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return readings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(preliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(
                            final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                        solvePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L115">115</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.html#L116">116</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L115">115</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L114">114</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final P initialPosition, final MixedPositionEstimatorListener&lt;P&gt; listener) {
        this(listener);
        this.initialPosition = initialPosition;
    }

    /**
     * Gets initial position to start position estimation.
     * If not defined, centroid of located sources position will be used to start
     * the estimation.
     *
     * @return initial position to start position estimation.
     */
    public P getInitialPosition() {
        return initialPosition;
    }

    /**
     * Sets initial position to start position estimation.
     * If not defined, centroid of located sources position will be used to start
     * the estimation.
     *
     * @param initialPosition initial position to start position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPosition = initialPosition;
    }

    /**
     * Indicates whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @return true to take radio source position covariance into account, false
     * otherwise.
     */
    public boolean isRadioSourcePositionCovarianceUsed() {
        return useRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @param useRadioSourcePositionCovariance true to take radio source position
     *                                         covariance into account, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovarianceUsed(final boolean useRadioSourcePositionCovariance)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useRadioSourcePositionCovariance = useRadioSourcePositionCovariance;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @return distance standard deviation to use as fallback.
     */
    public double getFallbackDistanceStandardDeviation() {
        return fallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @param fallbackDistanceStandardDeviation distance standard deviation to use
     *                                          as fallback.
     * @throws LockedException if estimator is locked.
     */
    public void setFallbackDistanceStandardDeviation(final double fallbackDistanceStandardDeviation)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.fallbackDistanceStandardDeviation = fallbackDistanceStandardDeviation;
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform lateration.
     */
    @Override
    public int getMinRequiredSources() {
        return trilaterationSolver.getMinRequiredPositionsAndDistances();
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return trilaterationSolver.isReady();
    }

    /**
     * Returns boolean indicating whether this estimator is locked because an estimation
     * is already in progress.
     *
     * @return true if estimator is locked, false otherwise.
     */
    @Override
    public boolean isLocked() {
        return trilaterationSolver.isLocked();
    }

    /**
     * Gets standard deviations of distances from known located radio sources to the
     * location of provided readings in a fingerprint.
     * Distance standard deviations are used internally to solve lateration.
     *
     * @return standard deviations used internally.
     */
    public double[] getDistanceStandardDeviations() {
        return trilaterationSolver.getDistanceStandardDeviations();
    }

    /**
     * Estimates position based on provided located radio sources and readings of such
     * radio sources at an unknown location.
     *
     * @throws LockedException             if estimator is locked.
     * @throws NotReadyException           if estimator is not ready.
     * @throws PositionEstimationException if estimation fails for some other reason.
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, PositionEstimationException {
        try {
            trilaterationSolver.setInitialPosition(initialPosition);

            trilaterationSolver.solve();
            estimatedPositionCoordinates = trilaterationSolver.getEstimatedPositionCoordinates();
        } catch (final LaterationException e) {
            throw new PositionEstimationException(e);
        }
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    @Override
    public P[] getPositions() {
        return trilaterationSolver.getPositions();
    }

    /**
     * Gets Euclidean distances from known located radio sources to the location of
     * provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return Euclidean distances used internally.
     */
    @Override
    public double[] getDistances() {
        return trilaterationSolver.getDistances();
    }

    /**
     * Gets estimated covariance matrix for estimated position.
     *
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getCovariance() {
        return trilaterationSolver.getCovariance();
    }

    /**
     * Internally sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required minimum.
     */
    @Override
    protected void internalSetSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
        super.internalSetSources(sources);
        buildPositionsDistancesAndDistanceStandardDeviations();
    }

    /**
     * Internally sets fingerprint containing readings at an unknown location for provided
     * located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    @Override
    protected void internalSetFingerprint(
            final Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2354">2354</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2279">2279</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Solves preliminary solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions      instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {

        try {
            innerReadings.clear();
            for (final var samplesIndex : samplesIndices) {
                innerReadings.add(readings.get(samplesIndex));
            }

            // initial transmitted power and position might or might not be available
            innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
            innerEstimator.setInitialPosition(initialPosition);
            innerEstimator.setInitialPathLossExponent(initialPathLossExponent);

            innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
            innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L391">391</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L395">395</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new RANSACRobustEstimator&lt;&gt;(new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return RANSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L391">391</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L395">395</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new RANSACRobustEstimator&lt;&gt;(new RANSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return RANSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L456">456</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1566">1566</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1554">1554</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return initialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return initialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(final double initialPathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return transmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(final boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.transmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     *
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return pathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     *
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(final boolean pathLossEstimationEnabled) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.pathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return useReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(final boolean useReadingPositionCovariances) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.useReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     *
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    public abstract boolean isHomogeneousRangingLinearSolverUsed();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L806">806</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L806">806</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return qualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return stopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return readings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(preliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(
                            final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L256">256</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1884">1884</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear2D(
            final double fingerprintRssi, final double pathLossExponent, final Point2D fingerprintPosition,
            final Point2D radioSourcePosition, final Point2D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 2D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();

        final var mean = new double[]{
                fingerprintRssi, pathLossExponent, x1, y1, xa, ya, xi, yi
        };
        final var covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null
                &amp;&amp; fingerprintPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; fingerprintPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2, 3, 3,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null
                &amp;&amp; radioSourcePositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; radioSourcePositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(4, 4, 5, 5,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null
                &amp;&amp; estimatedPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH
                &amp;&amp; estimatedPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(6, 6, 7, 7,
                    estimatedPositionCovariance);
        }

        try {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L964">964</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1297">1297</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1285">1285</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%) for robust position estimation on ranging data. The
     * amount of confidence indicates the probability that the estimated result is
     * correct. Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return rangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(final double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return rssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence amount of confidence for robust position estimation as
     *                       a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(final double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return rangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set for
     *                             position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(final int rangingMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return rssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(final int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return refineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(final boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.refineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return keepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(final boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.keepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L944">944</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1297">1297</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1285">1285</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return rangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation
     *                          as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(final double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return rssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence amount of confidence for robust position estimation as a
     *                       value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(final double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.rssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return rangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set for
     *                             position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(final int rangingMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return rssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(final int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.rssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return refineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(final boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.refineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return keepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(final boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.keepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L318">318</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L318">318</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point2D initialPosition, final RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L128">128</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L131">131</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var sqrDist = f.sqrDistanceTo(fingerprint);
            if (sqrDist &lt; bestSqrDist) {
                bestSqrDist = sqrDist;
                result = f;
            }
        }

        return result;
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal Euclidean distances, within the collection
     * of provided fingerprints.
     *
     * @param fingerprint  fingerprint to find the k-nearest ones to.
     * @param fingerprints collection of fingerprints to make the search for the nearest ones.
     * @param k            number of nearest fingerprints to find.
     * @param &lt;P&gt;          a {@link Point} type.
     * @param &lt;S&gt;          a {@link RadioSource} type.
     * @return nearest fingerprints ordered from closest to farthest or an empty list if none could be found.
     * @throws IllegalArgumentException if either fingerprint or collection of fingerprints is null, or k is less than
     *                                  1.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    public static &lt;P extends Point&lt;?&gt;, S extends RadioSource&gt; List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt;
    findKNearestTo(final RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint, final Collection&lt;? extends
                           RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints, final int k) {

        final var result = new ArrayList&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt;();
        final var nearestSqrDistances = new ArrayList&lt;Double&gt;();
        findKNearestTo(fingerprint, fingerprints, k, result, nearestSqrDistances);

        return result;
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal Euclidean distances, within the collection
     * of provided fingerprints.
     *
     * @param fingerprint         fingerprint to find the k-nearest ones to.
     * @param fingerprints        collection of fingerprints ot make the search for the nearest ones.
     * @param k                   number of nearest fingerprints to find.
     * @param nearestFingerprints list where found nearest fingerprints will be stored ordered from closest to farthest
     *                            or an empty list if none could be found.
     * @param nearestSqrDistances list where squared signal Euclidean distances corresponding to found fingerprints will
     *                            be stored or an empty list if no fingerprint is found.
     * @param &lt;P&gt;                 a {@link Point} type.
     * @param &lt;S&gt;                 a {@link RadioSource} type.
     * @throws IllegalArgumentException if any parameter is null or k is less than 1.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public static &lt;P extends Point&lt;?&gt;, S extends RadioSource&gt; void findKNearestTo(
            final RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            final Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints,
            final int k,
            final List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; nearestFingerprints,
            final List&lt;Double&gt; nearestSqrDistances) {

        if (fingerprint == null || fingerprints == null || k &lt; 1 || nearestFingerprints == null
                || nearestSqrDistances == null) {
            throw new IllegalArgumentException();
        }

        nearestSqrDistances.clear();
        nearestFingerprints.clear();

        var maxSqrDist = Double.MAX_VALUE;
        for (final var f : fingerprints) {
            final var sqrDist = f.sqrDistanceTo(fingerprint);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L808">808</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L808">808</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L801">801</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L367">367</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L365">365</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) laterationSolver).getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration2DSolver) laterationSolver).setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROMedSRobustLateration2DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L367">367</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L365">365</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) laterationSolver).getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) laterationSolver).setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROMedSRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L906">906</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L900">900</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

            @Override
            public double[] getQualityScores() {
                return qualityScores;
            }

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return PROSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2354">2354</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L411">411</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2356">2356</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2278">2278</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2362">2362</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L834">834</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Solves preliminary solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions      instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2364">2364</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L834">834</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Solves preliminary solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions      instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2287">2287</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L834">834</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Solves preliminary solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions      instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) laterationSolver).getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) laterationSolver).setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROMedSRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L370">370</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) laterationSolver).getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) laterationSolver).setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROMedSRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L368">368</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) laterationSolver).getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) laterationSolver).setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROMedSRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L369">369</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L372">372</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L369">369</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L372">372</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2286">2286</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L834">834</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L419">419</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L834">834</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L446">446</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1566">1566</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1554">1554</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return initialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return initialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(final double initialPathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return transmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(final boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.transmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether radio source position estimation is enabled or not.
     *
     * @return true if position estimation is enabled, false otherwise.
     */
    public boolean isPositionEstimationEnabled() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L505">505</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L491">491</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return transmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(final boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.transmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided readings will be used.
     * &lt;p&gt;
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return initialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * &lt;p&gt;
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * &lt;p&gt;
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L820">820</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L798">798</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        return create(sourceQualityScores, fingerprintReadingQualityScores, sources, fingerprint, listener,
                DEFAULT_ROBUST_METHOD);
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     * @param distanceQualityScores      distance quality scores or null if not
     *                                   required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            final List&lt;Point3D&gt; positions, List&lt;Double&gt; distances, final List&lt;Double&gt; distanceStandardDeviations,
            final List&lt;Double&gt; distanceQualityScores) {
        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L809">809</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L319">319</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L319">319</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L809">809</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L319">319</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L319">319</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L283">283</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L292">292</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L282">282</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final Point2D initialPosition, final MixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(initialPosition, listener);
        initialize();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public Point2D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point2D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L294">294</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L282">282</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RangingAndRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(initialPosition, listener);
        initialize();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public Point3D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point3D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.html#L797">797</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L822">822</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.html#L818">818</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.html#L799">799</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        return create(sourceQualityScores, fingerprintReadingQualityScores, sources, fingerprint, listener,
                DEFAULT_ROBUST_METHOD);
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     * @param distanceQualityScores      distance quality scores or null if not
     *                                   required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            final List&lt;Point2D&gt; positions, List&lt;Double&gt; distances, final List&lt;Double&gt; distanceStandardDeviations,
            final List&lt;Double&gt; distanceQualityScores) {
        final var size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L49">49</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L44">44</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public abstract class SequentialRobustMixedPositionEstimator&lt;P extends Point&lt;?&gt;&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RANGING_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;

    /**
     * Default robust method for coarse robust position estimation using RSSI
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation for ranging
     * measurements.
     */
    public static final boolean DEFAULT_USE_RANGING_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation for RSSI
     * measurements.
     */
    public static final boolean DEFAULT_USE_RSSI_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_RANGING_READINGS = true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_RSSI_READINGS = true;

    /**
     * Distance standard deviation assumed for provided distances as a fallback when
     * none can be determined.
     */
    public static final double FALLBACK_DISTANCE_STANDARD_DEVIATION =
            RobustPositionEstimator.FALLBACK_DISTANCE_STANDARD_DEVIATION;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default, this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen sub-samples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Indicates that by default a linear solver is used for preliminary solution
     * estimation using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_RANGING_LINEAR_SOLVER = true;

    /**
     * Indicates that by default a linear solver is used for preliminary solution
     * estimation using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_RSSI_LINEAR_SOLVER = true;

    /**
     * Indicates that by default an homogeneous linear solver is used either to
     * estimate preliminary solutions or an initial solution for preliminary solutions
     * that will be later refined on the ranging fine estimation.
     */
    public static final boolean DEFAULT_USE_RANGING_HOMOGENEOUS_LINEAR_SOLVER = false;

    /**
     * Indicates that by default an homogeneous linear solver is used either to
     * estimate preliminary solutions or an initial solution for preliminary solutions
     * that will be later refined on the RSSI coarse estimation.
     */
    public static final boolean DEFAULT_USE_RSSI_HOMOGENEOUS_LINEAR_SOLVER = false;

    /**
     * Indicates that by default preliminary ranging solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_RANGING_PRELIMINARY_SOLUTIONS = true;

    /**
     * Indicates that by default preliminary RSSI solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_RSSI_PRELIMINARY_SOLUTIONS = true;

    /**
     * Internal robust estimator for position estimation using ranging readings.
     */
    protected RobustRangingPositionEstimator&lt;P&gt; rangingEstimator;

    /**
     * Internal robust estimator for coarse position estimation using RSSI readings.
     */
    protected RobustRssiPositionEstimator&lt;P&gt; rssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
    protected RobustEstimatorMethod rangingRobustMethod = DEFAULT_RANGING_ROBUST_METHOD;

    /**
     * Robust method used for coarse robust position estimation using RSSI data.
     */
    protected RobustEstimatorMethod rssiRobustMethod = DEFAULT_RSSI_ROBUST_METHOD;

    /**
     * Size of subsets to be checked during robust estimation.
     */
    protected int rangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int rssiPreliminarySubsetSize;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L323">323</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L323">323</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point2D initialPosition, final RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L806">806</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L806">806</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L806">806</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L808">808</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L172">172</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L172">172</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on ranging distances.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on ranging distances.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new RANSACRobustEstimator&lt;&gt;(new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L391">391</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L391">391</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L395">395</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L395">395</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new RANSACRobustEstimator&lt;&gt;(new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L1986">1986</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L1878">1878</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {
        if (fingerprint == null) {
            throw new IllegalArgumentException();
        }

        this.fingerprint = fingerprint;
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples for 2D or 4 samples for 3D.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than 3 samples for 2D or 4 samples for 3D.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;
    }

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReading&lt;RadioSource&gt; createRangingReading(
            final RangingAndRssiReading&lt;? extends RadioSource&gt; reading) {
        return new RangingReading&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getDistanceStandardDeviation(),
                reading.getNumAttemptedMeasurements(), reading.getNumSuccessfulMeasurements());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReading&lt;RadioSource&gt; createRssiReading(final RangingAndRssiReading&lt;? extends RadioSource&gt; reading) {
        return new RssiReading&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getRssiStandardDeviation());
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L365">365</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L365">365</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1017">1017</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1017">1017</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1011">1011</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>PROSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                }
            }
        });

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            inliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(computeAndKeepInliers || refineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(computeAndKeepResiduals || refineResult);
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than required minimum.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
        if (qualityScores == null || qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        this.qualityScores = qualityScores;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator2D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator2D.html#L151">151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator2D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator2D.html#L151">151</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final MixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(listener);
        initialize();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions and distances on internal lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @throws IllegalArgumentException if something fails.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsAndDistances(
            final List&lt;Point2D&gt; positions, final List&lt;Double&gt; distances) {
        final var size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
        }

        try {
            homogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray, distancesArray);
            inhomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray, distancesArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        homogeneousTrilaterationSolver = new HomogeneousLinearLeastSquaresLateration2DSolver(laterationSolverListener);
        inhomogeneousTrilaterationSolver = new InhomogeneousLinearLeastSquaresLateration2DSolver(
                laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator3D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator3D.html#L151">151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator3D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator3D.html#L151">151</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final MixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(listener);
        initialize();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    @Override
    public Point3D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions and distances on internal lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @throws IllegalArgumentException if something fails.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsAndDistances(
            final List&lt;Point3D&gt; positions, final List&lt;Double&gt; distances) {
        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
        }

        try {
            homogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray, distancesArray);
            inhomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray, distancesArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        homogeneousTrilaterationSolver = new HomogeneousLinearLeastSquaresLateration3DSolver(laterationSolverListener);
        inhomogeneousTrilaterationSolver = new InhomogeneousLinearLeastSquaresLateration3DSolver(
                laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L836">836</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L830">830</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L814">814</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            final List&lt;Point3D&gt; positions, List&lt;Double&gt; distances, final List&lt;Double&gt; distanceStandardDeviations,
            final List&lt;Double&gt; distanceQualityScores) {
        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1096">1096</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2344">2344</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Checks number of available ranging readings and number of available RSSI readings. Also determines
     * whether position must be estimated using ranging data or RSSI data.
     *
     * @param readings readings to be checked.
     */
    private void checkReadings(final List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {
        numRangingReadings = numRssiReadings = 0;

        if (readings == null) {
            return;
        }

        for (final var reading : readings) {
            if (reading instanceof RangingReadingLocated) {
                numRangingReadings++;

            } else if (reading instanceof RssiReadingLocated) {
                numRssiReadings++;

            } else if (reading instanceof RangingAndRssiReadingLocated) {
                numRangingReadings++;
                numRssiReadings++;
            }
        }

        rssiPositionEnabled = numRangingReadings &lt; getMinRangingReadings();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2427">2427</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2350">2350</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>innerEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);

            innerEstimator.estimate();

            final var estimatedPosition = innerEstimator.getEstimatedPosition();
            final var estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
            final var estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition, estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch (final NavigationException ignore) {
            // if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled, and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(final Solution&lt;Point2D&gt; result) {
        final var initialPosition = result.getEstimatedPosition();
        final var initialTransmittedPowerdBm = result.getEstimatedTransmittedPowerdBm();
        final var initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (refineResult &amp;&amp; inliersData != null) {
            final var inliers = inliersData.getInliers();
            final var nSamples = readings.size();

            innerReadings.clear();

            for (var i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    // sample is inlier
                    innerReadings.add(readings.get(i));
                }
            }

            try {
                innerEstimator.setInitialPosition(initialPosition);
                innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                innerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
                innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2429">2429</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2348">2348</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>innerEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);

            innerEstimator.estimate();

            final var estimatedPosition = innerEstimator.getEstimatedPosition();
            final var estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
            final var estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition, estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch (final NavigationException ignore) {
            // if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled, and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(final Solution&lt;Point3D&gt; result) {
        final var initialPosition = result.getEstimatedPosition();
        final var initialTransmittedPowerdBm = result.getEstimatedTransmittedPowerdBm();
        final var initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (refineResult &amp;&amp; inliersData != null) {
            final var inliers = inliersData.getInliers();
            final var nSamples = readings.size();

            innerReadings.clear();

            for (var i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    // sample is inlier
                    innerReadings.add(readings.get(i));
                }
            }

            try {
                innerEstimator.setInitialPosition(initialPosition);
                innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                innerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
                innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L993">993</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L993">993</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L510">510</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L510">510</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L993">993</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L995">995</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            inliersData = null;

            // inlier thresholds are disabled to obtain a less restrictive amount of inliers
            innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
        if (qualityScores == null || qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        this.qualityScores = qualityScores;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L295">295</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L295">295</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public Point2D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point2D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L304">304</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L295">295</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public Point2D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point2D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L306">306</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L295">295</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public Point3D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point3D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L294">294</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L295">295</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public Point2D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point2D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L294">294</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L295">295</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public Point3D getEstimatedPosition() {
        if (estimatedPositionCoordinates == null) {
            return null;
        }

        final var result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                  positions to be set.
     * @param distances                  distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            final List&lt;Point3D&gt; positions, final List&lt;Double&gt; distances,
            final List&lt;Double&gt; distanceStandardDeviations) {

        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L816">816</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L837">837</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L831">831</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L815">815</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;Point3D&gt; positions, final List&lt;Double&gt; distances, final List&lt;Double&gt; distanceStandardDeviations,
            final List&lt;Double&gt; distanceQualityScores) {
        final var size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L921">921</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L438">438</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return qualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return stopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return readings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(preliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(
                            final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L921">921</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L438">438</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L923">923</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return qualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return stopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return readings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(preliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(
                            final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                        solvePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L946">946</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L456">456</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L940">940</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

            @Override
            public double[] getQualityScores() {
                return qualityScores;
            }

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return PROSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L946">946</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L456">456</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L939">939</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

            @Override
            public double[] getQualityScores() {
                return qualityScores;
            }

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return PROSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L644">644</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L644">644</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected void attemptRefine(final Solution&lt;Point2D&gt; result) {
        final var initialPosition = result.getEstimatedPosition();

        if (refineResult &amp;&amp; inliersData != null) {
            final var inliers = inliersData.getInliers();
            final var nSamples = readings.size();

            innerReadings.clear();

            for (var i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    // sample is inlier
                    innerReadings.add(readings.get(i));
                }
            }

            try {
                innerEstimator.setInitialPosition(initialPosition);
                innerEstimator.setReadings(innerReadings);

                innerEstimator.setNonLinearSolverEnabled(true);
                innerEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);
                innerEstimator.estimate();

                final var cov = innerEstimator.getEstimatedCovariance();
                if (keepCovariance &amp;&amp; cov != null) {
                    // keep covariance
                    estimatedPositionCovariance = covariance = cov;

                } else {
                    covariance = null;
                    estimatedPositionCovariance = null;
                }

                estimatedPosition = innerEstimator.getEstimatedPosition();
            } catch (final Exception e) {
                // refinement failed, so we return input value, and covariance
                // becomes unavailable
                covariance = null;
                estimatedPositionCovariance = null;

                estimatedPosition = initialPosition;
            }
        } else {
            covariance = null;
            estimatedPositionCovariance = null;

            estimatedPosition = initialPosition;
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L84">84</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.html#L85">85</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L85">85</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L84">84</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected LinearMixedPositionEstimator(final MixedPositionEstimatorListener&lt;P&gt; listener) {
        super(listener);
        init();
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate position.
     *
     * @return true if homogeneous linear solver is used, false if an inhomogeneous
     * linear one is used instead.
     */
    public boolean isHomogeneousLinearSolverUsed() {
        return useHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate position.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousLinearSolverUsed(final boolean useHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.useHomogeneousLinearSolver = useHomogeneousLinearSolver;
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform lateration.
     */
    @Override
    public int getMinRequiredSources() {
        return useHomogeneousLinearSolver
                ? homogeneousTrilaterationSolver.getMinRequiredPositionsAndDistances()
                : inhomogeneousTrilaterationSolver.getMinRequiredPositionsAndDistances();
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return (!useHomogeneousLinearSolver &amp;&amp; inhomogeneousTrilaterationSolver.isReady())
                || (useHomogeneousLinearSolver &amp;&amp; homogeneousTrilaterationSolver.isReady());
    }

    /**
     * Returns boolean indicating whether this estimator is locked because an estimation is already in progress.
     *
     * @return true if estimator is locked, false otherwise.
     */
    @Override
    public boolean isLocked() {
        return inhomogeneousTrilaterationSolver.isLocked() || homogeneousTrilaterationSolver.isLocked();
    }

    /**
     * Estimates position based on provided located radio sources and RSSI readings of
     * such radio sources at an unknown location.
     *
     * @throws LockedException             if estimator is locked.
     * @throws NotReadyException           if estimator is not ready.
     * @throws PositionEstimationException if estimation fails for some other reason.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, PositionEstimationException {
        try {
            if (useHomogeneousLinearSolver) {
                homogeneousTrilaterationSolver.solve();
                estimatedPositionCoordinates = homogeneousTrilaterationSolver.getEstimatedPositionCoordinates();
            } else {
                inhomogeneousTrilaterationSolver.solve();
                estimatedPositionCoordinates = inhomogeneousTrilaterationSolver.getEstimatedPositionCoordinates();
            }
        } catch (LaterationException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L826">826</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }

        final S source;
        final var reading = readings.get(0);
        if (reading instanceof RangingReadingLocated) {
            source = ((RangingReadingLocated&lt;S, Point2D&gt;) reading).getSource();
        } else if (reading instanceof RssiReadingLocated) {
            source = ((RssiReadingLocated&lt;S, Point2D&gt;) reading).getSource();
        } else if (reading instanceof RangingAndRssiReadingLocated) {
            source = ((RangingAndRssiReadingLocated&lt;S, Point2D&gt;) reading).getSource();
        } else {
            return null;
        }

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathLossExponent = getEstimatedPathLossExponent();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L825">825</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public RadioSourceLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }

        final S source;
        final var reading = readings.get(0);
        if (reading instanceof RangingReadingLocated) {
            source = ((RangingReadingLocated&lt;S, Point3D&gt;) reading).getSource();
        } else if (reading instanceof RssiReadingLocated) {
            source = ((RssiReadingLocated&lt;S, Point3D&gt;) reading).getSource();
        } else if (reading instanceof RangingAndRssiReadingLocated) {
            source = ((RangingAndRssiReadingLocated&lt;S, Point3D&gt;) reading).getSource();
        } else {
            return null;
        }

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathLossExponent = getEstimatedPathLossExponent();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PositionEstimator.html#L74">74</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustPositionEstimator.html#L137">137</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected PositionEstimator(final L listener) {
        this.listener = listener;
    }

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;RadioSourceLocated&lt;P&gt;&gt; getSources() {
        //noinspection unchecked
        return (List&lt;RadioSourceLocated&lt;P&gt;&gt;) sources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of provided
     *                                  sources is less than the required minimum.
     */
    public void setSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt; getFingerprint() {
        //noinspection unchecked
        return (Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt;) fingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(final Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
        return listener;
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     *
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(final L listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.listener = listener;
    }

    /**
     * Gets estimated inhomogeneous position coordinates.
     *
     * @return estimated inhomogeneous position coordinates.
     */
    public double[] getEstimatedPositionCoordinates() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.html#L185">185</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointLocated2D(accessPoint.getBssid(), accessPoint.getFrequency(),
                    accessPoint.getSsid(), estimatedPosition, estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconLocated2D(beacon.getIdentifiers(), beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(), beacon.getManufacturer(),
                    beacon.getServiceUuid(), beacon.getBluetoothName(), estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds an instance of a linear lateration solver if needed.
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.html#L185">185</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public RadioSourceLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointLocated3D(accessPoint.getBssid(), accessPoint.getFrequency(),
                    accessPoint.getSsid(), estimatedPosition, estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconLocated3D(beacon.getIdentifiers(), beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(), beacon.getManufacturer(),
                    beacon.getServiceUuid(), beacon.getBluetoothName(), estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds an instance of a linear lateration solver if needed.
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator3D.html#L161">161</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L160">160</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L157">157</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     *
     * @param i           number of sample being evaluated.
     * @param point       point where function will be evaluated.
     * @param params      initial parameters estimation to be tried. These will
     *                    change as the Levenberg-Marquardt algorithm iterates to the best solution.
     *                    These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     *                    provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(final int i, final double[] point, final double[] params, final double[] derivatives) {
        // This method implements received power at point pi = (xi, yi, zi) and its derivatives

        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //   - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)

        final var xi = params[0];
        final var yi = params[1];
        final var zi = params[2];

        // received power
        final var pr = point[0];

        // fingerprint coordinates
        final var x1 = point[1];
        final var y1 = point[2];
        final var z1 = point[3];

        //radio source coordinates
        final var xa = point[4];
        final var ya = point[5];
        final var za = point[6];

        // path loss exponent
        final var n = point[7];

        final var ln10 = Math.log(10.0);

        final var diffXi1 = xi - x1;
        final var diffYi1 = yi - y1;
        final var diffZi1 = zi - z1;

        final var diffX1a = x1 - xa;
        final var diffY1a = y1 - ya;
        final var diffZ1a = z1 - za;

        final var diffX1a2 = diffX1a * diffX1a;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2313">2313</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2195">2195</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private void internalSetReadings(final List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {
        if (!areValidReadings(readings)) {
            throw new IllegalArgumentException();
        }

        this.readings = readings;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than required minimum.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
        if (qualityScores == null || qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        this.qualityScores = qualityScores;
    }

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(), reading.getPositionCovariance());
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator2D.html#L151">151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator2D.html#L150">150</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated
     * position and distances provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((RANSACRobustLateration2DSolver) laterationSolver).getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated position
     * and distances provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        ((RANSACRobustLateration2DSolver) laterationSolver).setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((RANSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not
     *                              kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        ((RANSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((RANSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((RANSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new RANSACRobustLateration2DSolver(trilaterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator3D.html#L151">151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated
     * position and distances provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((RANSACRobustLateration3DSolver) laterationSolver).getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated position
     * and distances provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        ((RANSACRobustLateration3DSolver) laterationSolver).setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((RANSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not
     *                              kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        ((RANSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((RANSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((RANSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new RANSACRobustLateration3DSolver(trilaterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L485">485</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L262">262</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L489">489</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new RANSACRobustEstimator&lt;&gt;(new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return RANSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L485">485</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L262">262</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L488">488</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new RANSACRobustEstimator&lt;&gt;(new RANSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return RANSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L234">234</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L444">444</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var value1 = -10.0 * n * diffX1a / (ln10 * d1a2);
        final var value2 = -10.0 * n * diffY1a / (ln10 * d1a2);
        final var value3 = -10.0 * n * diffZ1a / (ln10 * d1a2);
        final var value4 = -5.0 * n * (-diffX1a2 + diffY1a2 + diffZ1a2) / (ln10 * d1a4);
        final var value5 = -5.0 * n * (diffX1a2 - diffY1a2 + diffZ1a2) / (ln10 * d1a4);
        final var value6 = -5.0 * n * (diffX1a2 + diffY1a2 - diffZ1a2) / (ln10 * d1a4);
        final var value7 = 20.0 * n * diffX1a * diffY1a / (ln10 * d1a4);
        final var value8 = 20.0 * n * diffY1a * diffZ1a / (ln10 * d1a4);
        final var value9 = 20.0 * n * diffX1a * diffZ1a / (ln10 * d1a4);

        final var result = pr</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L808">808</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L438">438</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L921">921</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;&gt;(
                new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return qualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return stopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return readings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(preliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(
                            final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L354">354</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L353">353</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public PROMedSRobustRssiPositionEstimator3D(
            final double[] sourceQualityScores, final double[] fingerprintReadingQualityScores,
            final List&lt;? extends RadioSourceLocated&lt;Point3D&gt;&gt; sources,
            final RssiFingerprint&lt;? extends RadioSource, ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L808">808</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L802">802</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L801">801</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final double initialPathLossExponent, final RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers) throws LockedException {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1017">1017</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L550">550</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L550">550</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L327">327</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L327">327</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L554">554</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L551">551</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>PROSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                }
            }
        });

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            inliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(computeAndKeepInliers || refineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(computeAndKeepResiduals || refineResult);
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2262">2262</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2142">2142</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

        rssiEstimator.setProgressDelta(2.0f * progressDelta);
        rssiEstimator.setConfidence(rssiConfidence);
        rssiEstimator.setMaxIterations(rssiMaxIterations);
        rssiEstimator.setResultRefined(refineResult);
        rssiEstimator.setCovarianceKept(keepCovariance);

        // initial position is not set because position estimated from ranging measures
        // will be later used
        rssiEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
        rssiEstimator.setInitialPathLossExponent(initialPathLossExponent);

        rssiEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
        rssiEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);

        rssiEstimator.setListener(new RobustRssiRadioSourceEstimatorListener&lt;&gt;() {
            @Override
            public void onEstimateStart(final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
            }

            @Override
            public void onEstimateEnd(final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
            }

            @Override
            public void onEstimateNextIteration(
                    final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator, final int iteration) {
                // not used
            }

            @Override
            public void onEstimateProgressChange(
                    final RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator, final float progress) {
                if (listener != null) {
                    listener.onEstimateProgressChange(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1042">1042</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L966">966</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public Double getEstimatedTransmittedPowerdBm() {
        return estimatedTransmittedPowerdBm;
    }

    /**
     * Gets estimated exponent typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * If path loss exponent estimation is not enabled, this value will always be equal to
     * {@link #DEFAULT_PATH_LOSS_EXPONENT}
     *
     * @return estimated path loss exponent.
     */
    public double getEstimatedPathLossExponent() {
        return estimatedPathLossExponent;
    }

    /**
     * Gets estimated transmitted power variance.
     * This value will only be available when transmitted power
     * estimation is enabled.
     *
     * @return estimated transmitted power variance or null.
     */
    public Double getEstimatedTransmittedPowerVariance() {
        return estimatedTransmittedPowerVariance;
    }

    /**
     * Gets estimated path loss exponent variance.
     * This value will only be available when path-loss
     * exponent estimation is enabled.
     *
     * @return estimated path loss exponent variance or null.
     */
    public Double getEstimatedPathLossExponentVariance() {
        return estimatedPathLossExponentVariance;
    }

    /**
     * Creates inner estimators if needed.
     */
    protected abstract void createInnerEstimatorsIfNeeded();

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(), reading.getPositionCovariance());
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2185">2185</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2084">2084</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>rssiPositionEnabled = rangingReadings.size() &lt; rangingEstimator.getMinReadings();
        }

        rangingEstimator.setProgressDelta(2.0f * progressDelta);
        rangingEstimator.setConfidence(rangingConfidence);
        rangingEstimator.setMaxIterations(rangingMaxIterations);
        rangingEstimator.setResultRefined(refineResult);
        rangingEstimator.setCovarianceKept(keepCovariance);
        rangingEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);
        rangingEstimator.setHomogeneousLinearSolverUsed(useHomogeneousRangingLinearSolver);

        rangingEstimator.setInitialPosition(initialPosition);

        rangingEstimator.setListener(new RobustRangingRadioSourceEstimatorListener&lt;&gt;() {
            @Override
            public void onEstimateStart(final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
            }

            @Override
            public void onEstimateEnd(final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                // not used
            }

            @Override
            public void onEstimateNextIteration(
                    final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator, final int iteration) {
                // not used
            }

            @Override
            public void onEstimateProgressChange(
                    final RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator, final float progress) {
                if (listener != null) {
                    listener.onEstimateProgressChange(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L477">477</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L477">477</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROSACRobustLateration2DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L477">477</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L477">477</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROSACRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L487">487</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L485">485</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((PROSACRobustLateration2DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROSACRobustLateration2DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L487">487</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L485">485</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        ((PROSACRobustLateration3DSolver) laterationSolver).setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        laterationSolver = new PROSACRobustLateration3DSolver(trilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(final double[] sourceQualityScores) {
        if (sourceQualityScores == null || sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.sourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     *
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null
                || fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        this.fingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L819">819</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L842">842</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.html#L838">838</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.html#L819">819</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L842">842</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L840">840</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L834">834</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L818">818</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L319">319</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L803">803</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this solver is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/LinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/LinearFingerprintPositionEstimator.html#L110">110</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L594">594</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L465">465</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     *
     * @throws LockedException                if estimator is locked.
     * @throws NotReadyException              if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException, FingerprintEstimationException {

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanFinder = null;
            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;
            if (useNoMeanNearestFingerprintFinder) {
                //noinspection unchecked
                noMeanFinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(
                        (Collection&lt;RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints);
            } else {
                //noinspection unchecked
                finder = new RadioSourceKNearestFinder&lt;&gt;(
                        (Collection&lt;RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) locatedFingerprints);
            }

            estimatedPositionCoordinates = null;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L409">409</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L826">826</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings({&quot;unchecked&quot;, &quot;DuplicatedCode&quot;})
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), accessPoint.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L71">71</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L70">70</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public abstract class SequentialRobustMixedRadioSourceEstimator&lt;S extends RadioSource, P extends Point&lt;P&gt;&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_PANGING_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;

    /**
     * Default robust estimator method for path-loss exponent and transmitted power
     * estimation using RSSI data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD = RobustEstimatorMethod.PROMEDS;

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default, this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen sub-samples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that by default position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard deviation
     * assuming that both measures are statistically independent.
     */
    public static final boolean DEFAULT_USE_READING_POSITION_COVARIANCES = true;

    /**
     * Internal robust estimator for position estimation.
     */
    protected RobustRangingRadioSourceEstimator&lt;S, P&gt; rangingEstimator;

    /**
     * Internal robust estimator for path-loss exponent and transmitted power
     * estimation.
     */
    protected RobustRssiRadioSourceEstimator&lt;S, P&gt; rssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
    protected RobustEstimatorMethod rangingRobustMethod = DEFAULT_PANGING_ROBUST_METHOD;

    /**
     * Robust method used for path-loss exponent and transmitted power estimation
     * using RSSI data.
     */
    protected RobustEstimatorMethod rssiRobustMethod = DEFAULT_RSSI_ROBUST_METHOD;

    /**
     * Size of subsets to be checked during ranging robust estimation.
     */
    protected int rangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int rssiPreliminarySubsetSize;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     */
    protected Double rangingThreshold;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * path-loss exponent and transmitted power estimation.
     */
    protected Double rssiThreshold;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L533">533</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L534">534</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L302">302</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L303">303</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L525">525</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L524">524</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>LMedSRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            inliersData = null;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L505">505</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L453">453</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L443">443</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L491">491</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        this.initialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L533">533</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L475">475</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L475">475</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L258">258</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L254">254</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L476">476</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L476">476</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>LMedSRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            inliersData = null;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L873">873</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L863">863</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), beacon.getTransmittedPower(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds ranging estimator.
     */
    @Override
    protected void buildRangingEstimatorIfNeeded() {
        if (rangingEstimator == null || rangingEstimator.getMethod() != rangingRobustMethod) {
            rangingEstimator = RobustRangingRadioSourceEstimator2D.create(rangingRobustMethod);
        }
    }

    /**
     * build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    @Override
    protected void buildRssiEstimatorIfNeeded() throws LockedException {
        if (rssiEstimator == null || rssiEstimator.getMethod() != rssiRobustMethod) {
            rssiEstimator = RobustRssiRadioSourceEstimator2D.create(rssiRobustMethod);

            // rssi estimator will never need position estimator, but to
            // ensure it is ready we need to provide an initial position
            rssiEstimator.setPositionEstimationEnabled(false);
            rssiEstimator.setInitialPosition(Point2D.create());
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L871">871</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L863">863</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), beacon.getTransmittedPower(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds ranging estimator.
     */
    @Override
    protected void buildRangingEstimatorIfNeeded() {
        if (rangingEstimator == null || rangingEstimator.getMethod() != rangingRobustMethod) {
            rangingEstimator = RobustRangingRadioSourceEstimator3D.create(rangingRobustMethod);
        }
    }

    /**
     * Build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    @Override
    protected void buildRssiEstimatorIfNeeded() throws LockedException {
        if (rssiEstimator == null || rssiEstimator.getMethod() != rssiRobustMethod) {
            rssiEstimator = RobustRssiRadioSourceEstimator3D.create(rssiRobustMethod);

            // rssi estimator will never need position estimator, but to
            // ensure it is ready we need to provide an initial position
            rssiEstimator.setPositionEstimationEnabled(false);
            rssiEstimator.setInitialPosition(Point3D.create());
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2408">2408</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2410">2410</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {

        try {
            innerReadings.clear();
            for (final var samplesIndex : samplesIndices) {
                innerReadings.add(readings.get(samplesIndex));
            }

            // initial transmitted power and position might or might not be available
            innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
            innerEstimator.setInitialPosition(initialPosition);
            innerEstimator.setInitialPathLossExponent(initialPathLossExponent);

            innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
            innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);

            innerEstimator.setReadings(innerReadings);

            // indicates whether readings position covariances must be taken into account
            innerEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);

            innerEstimator.estimate();

            final var estimatedPosition = innerEstimator.getEstimatedPosition();
            final var estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
            final var estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition, estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch (final NavigationException ignore) {
            // if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled, and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(final Solution&lt;Point2D&gt; result) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2496">2496</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2424">2424</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2422">2422</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>if (transmittedPowerEstimationEnabled) {
                        // transmitted power estimation enabled
                        estimatedTransmittedPowerVariance = covariance.getElementAt(pos, pos);
                        pos++;
                    } else {
                        // transmitted power estimation disabled
                        estimatedTransmittedPowerVariance = null;
                    }

                    if (pathLossEstimationEnabled) {
                        // path-loss exponent estimation enabled
                        estimatedPathLossExponentVariance = covariance.getElementAt(pos, pos);
                    } else {
                        // path-loss exponent estimation disabled
                        estimatedPathLossExponentVariance = null;
                    }
                } else {
                    covariance = null;
                    estimatedPositionCovariance = null;
                    estimatedTransmittedPowerVariance = null;
                    estimatedPathLossExponentVariance = null;
                }

                estimatedPosition = innerEstimator.getEstimatedPosition();
                estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
                estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            } catch (final Exception e) {
                // refinement failed, so we return input value, and covariance
                // becomes unavailable
                covariance = null;
                estimatedPositionCovariance = null;
                estimatedTransmittedPowerVariance = null;
                estimatedPathLossExponentVariance = null;

                estimatedPosition = initialPosition;
                estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                estimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            covariance = null;
            estimatedPositionCovariance = null;
            estimatedTransmittedPowerVariance = null;
            estimatedPathLossExponentVariance = null;

            estimatedPosition = initialPosition;
            estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            estimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2498">2498</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2424">2424</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2422">2422</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>if (transmittedPowerEstimationEnabled) {
                        // transmitted power estimation enabled
                        estimatedTransmittedPowerVariance = covariance.getElementAt(pos, pos);
                        pos++;
                    } else {
                        // transmitted power estimation disabled
                        estimatedTransmittedPowerVariance = null;
                    }

                    if (pathLossEstimationEnabled) {
                        // path-loss exponent estimation enabled
                        estimatedPathLossExponentVariance = covariance.getElementAt(pos, pos);
                    } else {
                        // path-loss exponent estimation disabled
                        estimatedPathLossExponentVariance = null;
                    }
                } else {
                    covariance = null;
                    estimatedPositionCovariance = null;
                    estimatedTransmittedPowerVariance = null;
                    estimatedPathLossExponentVariance = null;
                }

                estimatedPosition = innerEstimator.getEstimatedPosition();
                estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
                estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            } catch (final Exception e) {
                // refinement failed, so we return input value, and covariance
                // becomes unavailable
                covariance = null;
                estimatedPositionCovariance = null;
                estimatedTransmittedPowerVariance = null;
                estimatedPathLossExponentVariance = null;

                estimatedPosition = initialPosition;
                estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                estimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            covariance = null;
            estimatedPositionCovariance = null;
            estimatedTransmittedPowerVariance = null;
            estimatedPathLossExponentVariance = null;

            estimatedPosition = initialPosition;
            estimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            estimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2333">2333</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2331">2331</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {

        try {
            innerReadings.clear();
            for (final var samplesIndex : samplesIndices) {
                innerReadings.add(readings.get(samplesIndex));
            }

            // initial transmitted power and position might or might not be available
            innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
            innerEstimator.setInitialPosition(initialPosition);
            innerEstimator.setInitialPathLossExponent(initialPathLossExponent);

            innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
            innerEstimator.setPositionEstimationEnabled(positionEstimationEnabled);
            innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);

            innerEstimator.setReadings(innerReadings);

            innerEstimator.estimate();

            final var estimatedPosition = innerEstimator.getEstimatedPosition();
            final var estimatedTransmittedPowerdBm = innerEstimator.getEstimatedTransmittedPowerdBm();
            final var estimatedPathLossExponent = innerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition, estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch (final NavigationException ignore) {
            // if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled, and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(final Solution&lt;Point2D&gt; result) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator2D.html#L165">165</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.html#L165">165</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.html#L165">165</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     *
     * @param i           number of sample being evaluated.
     * @param point       point where function will be evaluated.
     * @param params      initial parameters estimation to be tried. These will
     *                    change as the Levenberg-Marquardt algorithm iterates to the best solution.
     *                    These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     *                    provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(
            final int i, final double[] point, final double[] params, final double[] derivatives) {
        // This method implements received power at point pi = (xi, yi) and its derivatives

        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)

        final var xi = params[0];
        final var yi = params[1];

        // received power
        final var pr = point[0];

        // fingerprint coordinates
        final var x1 = point[1];
        final var y1 = point[2];

        // radio source coordinates
        final var xa = point[3];
        final var ya = point[4];

        // path loss exponent
        final var n = point[5];

        final var ln10 = Math.log(10.0);

        final var diffXi1 = xi - x1;
        final var diffYi1 = yi - y1;

        final var diffX1a = x1 - xa;
        final var diffY1a = y1 - ya;

        final var diffX1a2 = diffX1a * diffX1a;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L347">347</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L347">347</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L346">346</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>listener.onEstimateEnd(NonLinearMixedPositionEstimator.this);
                }
            }
        };
    }

    /**
     * Builds positions, distances and standard deviation of distances for the internal
     * lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildPositionsDistancesAndDistanceStandardDeviations() {
        if (trilaterationSolver == null) {
            return;
        }

        final var min = getMinRequiredSources();
        if (sources == null || fingerprint == null || sources.size() &lt; min || fingerprint.getReadings() == null
                || fingerprint.getReadings().size() &lt; min) {
            return;
        }

        final var positions = new ArrayList&lt;P&gt;();
        final var distances = new ArrayList&lt;Double&gt;();
        final var distanceStandardDeviations = new ArrayList&lt;Double&gt;();
        PositionEstimatorHelper.buildPositionsDistancesAndDistanceStandardDeviations(sources, fingerprint,
                useRadioSourcePositionCovariance, fallbackDistanceStandardDeviation, positions, distances,
                distanceStandardDeviations);

        setPositionsDistancesAndDistanceStandardDeviations(positions, distances, distanceStandardDeviations);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L807">807</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L324">324</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L324">324</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L807">807</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L809">809</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L807">807</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L324">324</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L324">324</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if robust solver is locked because an
     *                                  estimation is already in progress.
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == readings.size();
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.html#L374">374</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.html#L374">374</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathLossExponent = getEstimatedPathLossExponent();

        final var pathLossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathLossExponentStandardDeviation = pathLossExponentVariance != null
                ? Math.sqrt(pathLossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), accessPoint.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L769">769</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L748">748</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected abstract void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;P&gt;&gt; solutions);

    /**
     * Estimates residual for a solution obtained for a subset of samples.
     *
     * @param currentEstimation solution obtained for a subset of samples.
     * @param i                 i-th fingerprint to obtain residual for.
     * @return difference between measured and expected RSSI value.
     */
    protected double residual(final Solution&lt;P&gt; currentEstimation, final int i) {
        // Model fitted internally is equal to:
        // Pr (dBm) = 10 * log(Pte * k^n / d^n) = 10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)
        // where:
        // Pr is received, expressed in dBm
        // Pte is equivalent transmitted power, expressed in dBm
        // k is a constant equal to k = c^2 / (pi * f)^2, where c is speed of light
        // and d is equal to distance between fingerprint and estimated position
        final var reading = readings.get(i);
        final var frequency = reading.getSource().getFrequency();

        final var pathLossExponent = currentEstimation.getEstimatedPathLossExponent();

        // compute k as the constant part of the isotropic received power formula
        // so that: Pr = Pte*k^n/d^n
        final var k = RssiRadioSourceEstimator.SPEED_OF_LIGHT / (4.0 * Math.PI * frequency);
        final var kdB = 10.0 * pathLossExponent * Math.log10(k);

        // get distance from estimated radio source position and reading position
        final var readingPosition = reading.getPosition();
        final var radioSourcePosition = currentEstimation.getEstimatedPosition();

        final var sqrDistance = radioSourcePosition.sqrDistanceTo(readingPosition);

        final var transmittedPowerdBm = currentEstimation.getEstimatedTransmittedPowerdBm();

        // compute expected received power assuming isotropic transmission
        // and compare against measured RSSI at fingerprint location
        final var expectedRSSI = kdB + transmittedPowerdBm - 5.0 * pathLossExponent * Math.log10(sqrDistance);
        final var rssi = reading.getRssi();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L392">392</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L173">173</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L173">173</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L392">392</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L173">173</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L173">173</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * iso-tropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2364">2364</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L417">417</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2286">2286</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L417">417</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.html#L817">817</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L819">819</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L840">840</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L834">834</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L818">818</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            laterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                laterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L196">196</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L199">199</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var sqrDist = f.sqrDistanceTo(fingerprint);
            if (sqrDist &lt; maxSqrDist || nearestSqrDistances.size() &lt; k) {

                // find insertion point
                var pos = -1;
                var i = 0;
                for (final var sd : nearestSqrDistances) {
                    if (sqrDist &lt; sd) {
                        // insertion point found
                        pos = i;
                        break;
                    }
                    i++;
                }

                if (pos &gt;= 0) {
                    nearestSqrDistances.add(pos, sqrDist);
                    nearestFingerprints.add(pos, f);
                } else {
                    nearestSqrDistances.add(sqrDist);
                    nearestFingerprints.add(f);
                }

                // remove results exceeding required number of k neighbours to be found
                if (nearestFingerprints.size() &gt; k) {
                    nearestSqrDistances.remove(k);
                    nearestFingerprints.remove(k);
                }

                // update maxSqrDist to the largest squared distance value contained in result list distances
                maxSqrDist = nearestSqrDistances.get(nearestSqrDistances.size() - 1);
            }
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L248">248</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L248">248</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L247">247</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>listener.onEstimateEnd(LinearMixedPositionEstimator.this);
                }
            }
        };
    }

    /**
     * Builds positions and distances for the internal lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildPositionsAndDistances() {
        if ((useHomogeneousLinearSolver &amp;&amp; homogeneousTrilaterationSolver == null)
                || (!useHomogeneousLinearSolver &amp;&amp; inhomogeneousTrilaterationSolver == null)) {
            return;
        }

        final var min = getMinRequiredSources();
        if (sources == null || fingerprint == null || sources.size() &lt; min || fingerprint.getReadings() == null
                || fingerprint.getReadings().size() &lt; min) {
            return;
        }

        final var positions = new ArrayList&lt;P&gt;();
        final var distances = new ArrayList&lt;Double&gt;();
        PositionEstimatorHelper.buildPositionsAndDistances(sources, fingerprint, positions, distances);

        setPositionsAndDistances(positions, distances);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L397">397</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L202">202</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L202">202</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L397">397</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L202">202</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L202">202</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.html#L265">265</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.html#L265">265</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        if (initialPosition == null || !nonLinearSolverEnabled) {
            if (homogeneousLinearSolver != null) {
                homogeneousLinearSolver.setPositionsAndDistances(positionsArray, distancesArray);
            }
            if (inhomogeneousLinearSolver != null) {
                inhomogeneousLinearSolver.setPositionsAndDistances(positionsArray, distancesArray);
            }
        }

        if (nonLinearSolver != null &amp;&amp; nonLinearSolverEnabled) {
            nonLinearSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L484">484</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2464">2464</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point3D radioSourcePosition, final Point3D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 3D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //   - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();
        final var z1 = fingerprintPosition.getInhomZ();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();
        final var za = radioSourcePosition.getInhomZ();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();
        final var zi = estimatedPosition.getInhomZ();

        final var mean = new double[]{</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1145">1145</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2464">2464</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point3D radioSourcePosition, final Point3D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 2nd order Taylor expression of received power in 3D:
        // Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //  - 5*n*((y1 - ya)^2 + (z1 - za)^2) - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
        //  - 5*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*d1a^4)*(yi - y1)^2
        //  - 5*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*d1a^4)*(zi - z1)^2
        //  + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1)
        //  + 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)*(yi - y1)*(zi - z1)
        //  + 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)*(xi - x1)*(zi - z1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();
        final var z1 = fingerprintPosition.getInhomZ();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();
        final var za = radioSourcePosition.getInhomZ();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();
        final var zi = estimatedPosition.getInhomZ();

        final var mean = new double[]{</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2076">2076</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2464">2464</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point3D radioSourcePosition, final Point3D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 3D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //   - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();
        final var z1 = fingerprintPosition.getInhomZ();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();
        final var za = radioSourcePosition.getInhomZ();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();
        final var zi = estimatedPosition.getInhomZ();

        final var mean = new double[]{</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L710">710</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1838">1838</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>jacobian.setElementAtIndex(0, derivativeFingerprintRssi);
                    jacobian.setElementAtIndex(1, derivativePathLossExponent);
                    jacobian.setElementAtIndex(2, derivativeX1);
                    jacobian.setElementAtIndex(3, derivativeY1);
                    jacobian.setElementAtIndex(4, derivativeZ1);
                    jacobian.setElementAtIndex(5, derivativeXa);
                    jacobian.setElementAtIndex(6, derivativeYa);
                    jacobian.setElementAtIndex(7, derivativeZa);
                    jacobian.setElementAtIndex(8, derivativeXi);
                    jacobian.setElementAtIndex(9, derivativeYi);
                    jacobian.setElementAtIndex(10, derivativeZi);
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (final AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 2D 2nd order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     *
     * @param fingerprintRssi               closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non-linear algorithm.
     * @param fingerprintRssiVariance       variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance   covariance of position to be estimated or null
     *                                      if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceSecondOrderNonLinear2D(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L404">404</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.html#L404">404</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>} else if (source instanceof Beacon beacon) {
            // transmitted power does not need to be estimated for beacons because
            // they broadcast such information
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(), beacon.getTransmittedPower(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(), pathLossExponent,
                    transmittedPowerStandardDeviation, pathLossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Creates inner estimators if needed.
     */
    @Override
    protected void createInnerEstimatorsIfNeeded() {
        if (rangingInnerEstimator == null) {
            rangingInnerEstimator = new RangingRadioSourceEstimator2D&lt;&gt;();
        }

        if (rssiInnerEstimator == null &amp;&amp; (transmittedPowerEstimationEnabled || pathLossEstimationEnabled)) {
            rssiInnerEstimator = new RssiRadioSourceEstimator2D&lt;&gt;();
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L403">403</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.html#L404">404</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>} else if (source instanceof Beacon beacon) {
            // transmitted power does not need to be estimated for beacons because
            // they broadcast such information
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), beacon.getTransmittedPower(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(), pathLossExponent,
                    transmittedPowerStandardDeviation, pathLossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Creates inner estimators if needed.
     */
    @Override
    protected void createInnerEstimatorsIfNeeded() {
        if (rangingInnerEstimator == null) {
            rangingInnerEstimator = new RangingRadioSourceEstimator3D&lt;&gt;();
        }

        if (rssiInnerEstimator == null &amp;&amp; (transmittedPowerEstimationEnabled || pathLossEstimationEnabled)) {
            rssiInnerEstimator = new RssiRadioSourceEstimator3D&lt;&gt;();
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2451">2451</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2374">2374</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2372">2372</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>protected void attemptRefine(final Solution&lt;Point2D&gt; result) {
        final var initialPosition = result.getEstimatedPosition();
        final var initialTransmittedPowerdBm = result.getEstimatedTransmittedPowerdBm();
        final var initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (refineResult &amp;&amp; inliersData != null) {
            final var inliers = inliersData.getInliers();
            final var nSamples = readings.size();

            innerReadings.clear();

            for (var i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    // sample is inlier
                    innerReadings.add(readings.get(i));
                }
            }

            try {
                innerEstimator.setInitialPosition(initialPosition);
                innerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                innerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                innerEstimator.setTransmittedPowerEstimationEnabled(transmittedPowerEstimationEnabled);
                innerEstimator.setPathLossEstimationEnabled(pathLossEstimationEnabled);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L392">392</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L399">399</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(
                new LMedSRobustEstimatorListener&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L392">392</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L393">393</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(
                new LMedSRobustEstimatorListener&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L393">393</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L398">398</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(
                new LMedSRobustEstimatorListener&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point3D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L175">175</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(new LMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L150">150</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L887">887</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L429">429</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L429">429</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L887">887</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L429">429</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L429">429</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L880">880</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L429">429</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L429">429</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L560">560</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L560">560</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return new BeaconLocated2D(beacon.getIdentifiers(), beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(), beacon.getManufacturer(),
                    beacon.getServiceUuid(), beacon.getBluetoothName(), estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position.
     *
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    @Override
    public boolean isHomogeneousLinearSolverUsed() {
        return innerEstimator.isHomogeneousLinearSolverUsed();
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate an initial
     * position.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    @Override
    public void setHomogeneousLinearSolverUsed(final boolean useHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        innerEstimator.setHomogeneousLinearSolverUsed(useHomogeneousLinearSolver);
    }

    /**
     * Solves preliminary solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions      instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L369">369</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L369">369</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L372">372</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L372">372</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2019">2019</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2239">2239</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            };

            final var jacobianEstimator = new JacobianEstimator(evaluator);

            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(final double[] x, final double[] y, final Matrix jacobian) {

                    try {
                        evaluator.evaluate(x, y);
                        jacobianEstimator.jacobian(x, jacobian);
                    } catch (final EvaluationException ignore) {
                        //never happens
                    }
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (final AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 3D 3rd order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     *
     * @param fingerprintRssi               closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non-linear algorithm.
     * @param fingerprintRssiVariance       variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance   covariance of position to be estimated or null
     *                                      if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceThirdOrderNonLinear3D(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L367">367</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L367">367</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L365">365</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L365">365</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) laterationSolver).getStopThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L367">367</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L365">365</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) laterationSolver).getThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L367">367</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L365">365</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration3DSolver) laterationSolver).getThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L392">392</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L399">399</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L398">398</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if this solver is locked.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(
                new LMedSRobustEstimatorListener&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2363">2363</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2365">2365</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2288">2288</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2287">2287</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L420">420</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L418">418</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L835">835</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        final var readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        final var source = readings.get(0).getSource();

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L508">508</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1566">1566</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1554">1554</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L499">499</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1566">1566</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1554">1554</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1566">1566</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1554">1554</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return initialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(final Double initialTransmittedPowerdBm) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.initialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return initialTransmittedPowerdBm != null ? Utils.dBmToPower(initialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * &lt;p&gt;
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will be converted to the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(final Double initialTransmittedPower) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            initialTransmittedPowerdBm = Utils.powerTodBm(initialTransmittedPower);
        } else {
            initialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L419">419</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L271">271</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L498">498</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L419">419</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L271">271</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L497">497</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L422">422</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L271">271</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L498">498</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L422">422</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L271">271</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L497">497</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L906">906</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L900">900</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L900">900</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L899">899</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L367">367</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L365">365</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L410">410</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L192">192</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L413">413</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L410">410</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L191">191</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L413">413</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L576">576</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>y[0] = fingerprintRssi - 10.0 * pathLossExponent * crossDiff / (ln10 * d1a2);

                    // compute gradient (is a jacobian having 1 row and 8 columns)

                    // derivative of rssi respect to fingerprint rssi
                    final var derivativeFingerprintRssi = 1.0;

                    // derivative of rssi respect to path-loss exponent

                    // diff(Pr(pi))/diff(n) = -10*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //   -10*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    final var derivativePathLossExponent = -10.0 * crossDiff / (ln10 * d1a2);

                    // derivative of rssi respect to x1

                    // We have
                    // Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/
                    //       (ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                    // and we know that: (f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2
                    // and also that (f(x)*g(x))' = f'(x)*g(x) + f(x)*g'(x)

                    // Hence
                    // diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(x1) =
                    //   diff(x1*xi -xa*xi -x1^2 + xa*x1)/diff(x1) =
                    //   diff(-x1^2 + (xi + xa)*x1 - xa*xi)/diff(x1) =
                    //   -2*x1 + xi + xa

                    // diff(Pr(pi))/diff(x1) = -10*n/ln(10)*((-2*x1 + xi + xa)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    // diff(Pr(pi))/diff(x1) = -10*n/ln(10)*((-2*x1 + xi + xa)*d1a^2 - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/d1a^4
                    final var tmpX = 2.0 * crossDiff * diffX1a;
                    final var derivativeX1 = -10.0 * pathLossExponent / ln10 * ((-2.0 * x1 + xi + xa) * d1a2
                            - tmpX) / d1a4;

                    // derivative of rssi respect to y1

                    // diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(y1) =
                    //   diff(y1*yi -ya*yi -y1^2 + ya*y1)/diff(y1) =
                    //   diff(-y1^2 + (yi + ya)*y1 - ya*yi)/diff(y1) =
                    //   -2*y1 + yi + ya

                    // diff(Pr(pi))/diff(y1) = -10*n/ln(10)*((-2*y1 + yi + ya)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(y1 - ya))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    // diff(Pr(pi))/diff(y1) = -10*n/ln(10)*((-2*y1 + yi + ya)*d1a^2 - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(y1 - ya))/d1a^4
                    final var tmpY = 2.0 * crossDiff * diffY1a;
                    final var derivativeY1 = -10.0 * pathLossExponent / ln10 * ((-2.0 * y1 + yi + ya) * d1a2
                            - tmpY) / d1a4;


                    // derivative of rssi respect to xa

                    // diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(xa) =
                    //   diff(x1*xi -xa*xi -x1^2 + xa*x1)/diff(xa) =
                    //   x1 - xi

                    // diff(Pr(pi))/diff(xa) = -10*n/ln(10)*((x1 - xi)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*-2*(x1 - xa))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    // diff(Pr(pi))/diff(xa) = -10*n/ln(10)*(-(xi - x1)*d1a^2 + ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/d1a^4
                    final var derivativeXa = -10.0 * pathLossExponent / ln10 * (-diffXi1 * d1a2 + tmpX) / d1a4;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L367">367</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L365">365</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L371">371</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L370">370</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>source = ((RangingAndRssiReadingLocated&lt;S, Point2D&gt;) reading).getSource();
        } else {
            return null;
        }

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathLossExponent = getEstimatedPathLossExponent();

        final var pathLossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathLossExponentStandardDeviation = pathLossExponentVariance != null
                ? Math.sqrt(pathLossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            if (transmittedPowerdBm != null) {
                return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), accessPoint.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L1484">1484</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L1464">1464</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     *
     * @return quality scores corresponding to each reading within provided fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public SequentialRobustMixedPositionEstimatorListener&lt;P&gt; getListener() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L877">877</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L823">823</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return areValidReadings(readings);
    }

    /**
     * Estimate position, transmitted power and path loss exponent.
     *
     * @throws RadioSourceEstimationException if estimation fails.
     * @throws NotReadyException              if estimator is not ready.
     * @throws LockedException                if estimator is locked.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public void estimate() throws RadioSourceEstimationException, NotReadyException, LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            locked = true;

            if (listener != null) {
                listener.onEstimateStart(this);
            }

            createInnerEstimatorsIfNeeded();

            final var rangingReadings = new ArrayList&lt;RangingReadingLocated&lt;S, P&gt;&gt;();
            final var rssiReadings = new ArrayList&lt;RssiReadingLocated&lt;S, P&gt;&gt;();
            for (final var reading : readings) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L1020">1020</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2226">2226</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(), reading.getPositionCovariance());
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L318">318</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L331">331</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L319">319</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L320">320</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>var positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(laterationSolverListener);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1096">1096</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2226">2226</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(), reading.getPositionCovariance());
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1008">1008</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1031">1031</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1031">1031</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1025">1025</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L564">564</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L341">341</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L341">341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L568">568</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1008">1008</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1031">1031</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1031">1031</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1025">1025</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L564">564</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L341">341</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L341">341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L568">568</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L525">525</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1031">1031</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1031">1031</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1025">1025</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L564">564</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L341">341</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L341">341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L568">568</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L525">525</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1031">1031</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1031">1031</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1025">1025</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L564">564</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L341">341</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L341">341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L568">568</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1008">1008</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1031">1031</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1031">1031</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1025">1025</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L564">564</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L341">341</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L341">341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L568">568</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1031">1031</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1031">1031</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1025">1025</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L564">564</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L341">341</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L341">341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L568">568</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L1020">1020</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2344">2344</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private RangingReadingLocated&lt;S, P&gt; createRangingReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(), reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(), reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(final RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(), reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(), reading.getPositionCovariance());
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L104">104</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L107">107</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Finds nearest fingerprint to provided one, in terms of signal Euclidean distances, within the collection of
     * provided fingerprints.
     *
     * @param fingerprint  fingerprint to find the nearest to.
     * @param fingerprints collection of fingerprints to make the search for the nearest one.
     * @param &lt;P&gt;          a {@link Point} type.
     * @param &lt;S&gt;          a {@link RadioSource} type.
     * @return nearest fingerprint or null if none could be found.
     * @throws IllegalArgumentException if either fingerprint or collection of fingerprints is null.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public static &lt;P extends Point&lt;?&gt;, S extends RadioSource&gt; RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; findNearestTo(
            final RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            final Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints) {
        if (fingerprint == null || fingerprints == null) {
            throw new IllegalArgumentException();
        }

        var bestSqrDist = Double.MAX_VALUE;
        RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; result = null;
        for (final var f : fingerprints) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L546">546</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L547">547</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L315">315</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L316">316</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L538">538</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L537">537</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L420">420</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L962">962</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L472">472</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L956">956</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L495">495</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L272">272</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L499">499</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L488">488</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L420">420</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L962">962</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L472">472</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L955">955</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L495">495</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L272">272</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L498">498</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L488">488</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L271">271</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L267">267</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L423">423</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L962">962</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L472">472</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L956">956</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L489">489</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L423">423</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L962">962</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L472">472</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L955">955</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L489">489</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1010">1010</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L527">527</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L527">527</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1012">1012</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1032">1032</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1032">1032</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1025">1025</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L565">565</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L342">342</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L342">342</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L569">569</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L566">566</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            attemptRefine(result);

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L900">900</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L445">445</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L445">445</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L449">449</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L448">448</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and path-loss exponent for a
     * radio source.
     *
     * @throws LockedException          if instance is busy during estimation.
     * @throws NotReadyException        if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;&gt;(new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L1328">1328</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L1452">1452</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}
        });

        final var numReadings = readings.size();
        try {
            final var x = new Matrix(numReadings, dimsPlus1);
            final var y = new double[numReadings];
            final var standardDeviations = new double[numReadings];
            for (var i = 0; i &lt; numReadings; i++) {
                reading = readings.get(i);
                final var position = reading.getPosition();

                for (var j = 0; j &lt; dims; j++) {
                    x.setElementAt(i, j, position.getInhomogeneousCoordinate(j));
                }
                x.setElementAt(i, dims, initialTransmittedPowerdBm);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L901">901</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L1504">1504</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings, final Point2D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener,
            final RobustEstimatorMethod method) {
        return switch (method) {
            case RANSAC -&gt; new RANSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case LMEDS -&gt; new LMedSRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case MSAC -&gt; new MSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case PROSAC -&gt; new PROSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L903">903</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L1506">1506</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings, final Point3D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener,
            final RobustEstimatorMethod method) {
        return switch (method) {
            case RANSAC -&gt; new RANSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case LMEDS -&gt; new LMedSRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case MSAC -&gt; new MSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case PROSAC -&gt; new PROSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L882">882</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L1465">1465</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings, final Point2D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener, final RobustEstimatorMethod method) {
        return switch (method) {
            case RANSAC -&gt; new RANSACRobustRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case LMEDS -&gt; new LMedSRobustRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case MSAC -&gt; new MSACRobustRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case PROSAC -&gt; new PROSACRobustRssiRadioSourceEstimator2D&lt;&gt;(readings, initialPosition,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L881">881</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L1464">1464</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;? extends RssiReadingLocated&lt;S, Point3D&gt;&gt; readings, final Point3D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener, final RobustEstimatorMethod method) {
        return switch (method) {
            case RANSAC -&gt; new RANSACRobustRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case LMEDS -&gt; new LMedSRobustRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case MSAC -&gt; new MSACRobustRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,
                    initialTransmittedPowerdBm, initialPathLossExponent, listener);
            case PROSAC -&gt; new PROSACRobustRssiRadioSourceEstimator3D&lt;&gt;(readings, initialPosition,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L839">839</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L838">838</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>source = ((RangingAndRssiReadingLocated&lt;S, Point2D&gt;) reading).getSource();
        } else {
            return null;
        }

        final var estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        final var estimatedPositionCovariance = getEstimatedPositionCovariance();

        final var transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        final var transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        final var transmittedPowerStandardDeviation = transmittedPowerVariance != null
                ? Math.sqrt(transmittedPowerVariance) : null;

        final var pathlossExponentVariance = getEstimatedPathLossExponentVariance();
        final var pathlossExponentStandardDeviation = pathlossExponentVariance != null
                ? Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint accessPoint) {
            if (transmittedPowerdBm != null) {
                return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(), source.getFrequency(),</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L363">363</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.html#L364">364</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L363">363</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L362">362</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var min = getMinRequiredSources();
        if (sources == null || fingerprint == null || sources.size() &lt; min || fingerprint.getReadings() == null
                || fingerprint.getReadings().size() &lt; min) {
            return;
        }

        final var positions = new ArrayList&lt;P&gt;();
        final var distances = new ArrayList&lt;Double&gt;();
        final var distanceStandardDeviations = new ArrayList&lt;Double&gt;();
        PositionEstimatorHelper.buildPositionsDistancesAndDistanceStandardDeviations(sources, fingerprint,
                useRadioSourcePositionCovariance, fallbackDistanceStandardDeviation, positions, distances,
                distanceStandardDeviations);

        setPositionsDistancesAndDistanceStandardDeviations(positions, distances, distanceStandardDeviations);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L166">166</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.html#L166">166</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L166">166</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L165">165</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>} catch (LaterationException e) {
            throw new PositionEstimationException(e);
        }
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    @Override
    public P[] getPositions() {
        return useHomogeneousLinearSolver
                ? homogeneousTrilaterationSolver.getPositions() : inhomogeneousTrilaterationSolver.getPositions();
    }

    /**
     * Gets Euclidean distances from known located radio sources to
     * the location of provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return Euclidean distances used internally.
     */
    @Override
    public double[] getDistances() {
        return useHomogeneousLinearSolver
                ? homogeneousTrilaterationSolver.getDistances() : inhomogeneousTrilaterationSolver.getDistances();
    }

    /**
     * Internally sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    @Override
    protected void internalSetSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
        super.internalSetSources(sources);
        buildPositionsAndDistances();
    }

    /**
     * Internally sets fingerprint containing readings at an unknown location for provided
     * located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    @Override
    protected void internalSetFingerprint(
            final Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L242">242</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L467">467</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(new LMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] sampleIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L243">243</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L466">466</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new LMedSRobustEstimator&lt;&gt;(new LMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] sampleIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2388">2388</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L441">441</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L858">858</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2310">2310</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L441">441</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(), source.getFrequency(),
                    accessPoint.getSsid(), getEstimatedTransmittedPowerdBm(), transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(), pathlossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else if (source instanceof Beacon beacon) {
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(), getEstimatedTransmittedPowerdBm(),
                    beacon.getFrequency(), beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(), beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(), transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation, estimatedPosition, estimatedPositionCovariance);
        } else {
            return null;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2068">2068</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1980">1980</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var rssiCov = rssiEstimator.getCovariance();
                    if (estimatedPositionCovariance != null &amp;&amp; rssiCov != null) {
                        final var dims = getNumberOfDimensions();
                        var n = dims;
                        if (transmittedPowerEstimationEnabled) {
                            n++;
                        }
                        if (pathLossEstimationEnabled) {
                            n++;
                        }

                        final var dimsMinus1 = dims - 1;
                        final var nMinus1 = n - 1;
                        covariance = new Matrix(n, n);
                        covariance.setSubmatrix(0, 0, dimsMinus1, dimsMinus1,
                                estimatedPositionCovariance);
                        covariance.setSubmatrix(dims, dims, nMinus1, nMinus1, rssiCov);
                    } else {
                        covariance = null;
                    }
                }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L439">439</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1100">1100</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>jacobian.setElementAtIndex(0, derivativeFingerprintRssi);
                    jacobian.setElementAtIndex(1, derivativePathLossExponent);
                    jacobian.setElementAtIndex(2, derivativeX1);
                    jacobian.setElementAtIndex(3, derivativeY1);
                    jacobian.setElementAtIndex(4, derivativeXa);
                    jacobian.setElementAtIndex(5, derivativeYa);
                    jacobian.setElementAtIndex(6, derivativeXi);
                    jacobian.setElementAtIndex(7, derivativeYi);
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (final AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 3D 1st order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     *
     * @param fingerprintRssi               closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non-linear algorithm.
     * @param fingerprintRssiVariance       variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance   covariance of position to be estimated or null
     *                                      if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) laterationSolver).getStopThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L370">370</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) laterationSolver).getStopThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L368">368</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) laterationSolver).getStopThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L360">360</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    @Override
    public double[] getSourceQualityScores() {
        return sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setSourceQualityScores(final double[] sourceQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    @Override
    public double[] getFingerprintReadingsQualityScores() {
        return fingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    @Override
    public void setFingerprintReadingsQualityScores(final double[] fingerprintReadingsQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) laterationSolver).getStopThreshold();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PositionEstimator.html#L76">76</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L1434">1434</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;RadioSourceLocated&lt;P&gt;&gt; getSources() {
        //noinspection unchecked
        return (List&lt;RadioSourceLocated&lt;P&gt;&gt;) sources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of provided
     *                                  sources is less than the required minimum.
     */
    public void setSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt; getFingerprint() {
        //noinspection unchecked
        return (Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt;) fingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(final Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint)</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustPositionEstimator.html#L139">139</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L1434">1434</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;RadioSourceLocated&lt;P&gt;&gt; getSources() {
        //noinspection unchecked
        return (List&lt;RadioSourceLocated&lt;P&gt;&gt;) sources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    public void setSources(final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt; getFingerprint() {
        //noinspection unchecked
        return (Fingerprint&lt;RadioSource, Reading&lt;RadioSource&gt;&gt;) fingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprint(
            final Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint) throws LockedException {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L320">320</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L318">318</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L329">329</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L331">331</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L319">319</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L319">319</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L320">320</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L320">320</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        final var distancesArray = new double[size];
        final var distanceStandardDeviationsArray = new double[size];
        for (var i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            trilaterationSolver.setPositionsDistancesAndStandardDeviations(positionsArray, distancesArray,
                    distanceStandardDeviationsArray);
        } catch (final LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void initialize() {
        trilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(laterationSolverListener);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L366">366</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L388">388</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACRobustRangingAndRssiRadioSourceEstimator2D(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings, final Point2D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L366">366</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L388">388</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACRobustRangingAndRssiRadioSourceEstimator3D(
            final List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings, final Point3D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L369">369</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L392">392</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACRobustRssiRadioSourceEstimator2D(
            final List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings, final Point2D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L369">369</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L392">392</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACRobustRssiRadioSourceEstimator3D(
            final List&lt;? extends RssiReadingLocated&lt;S, Point3D&gt;&gt; readings, final Point3D initialPosition,
            final Double initialTransmittedPowerdBm, final double initialPathLossExponent,
            final RobustRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm, initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L603">603</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L603">603</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected void solvePreliminarySolutions(final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
        try {
            innerReadings.clear();
            for (final var samplesIndex : samplesIndices) {
                innerReadings.add(readings.get(samplesIndex));
            }

            // initial position might or might not be available
            innerEstimator.setInitialPosition(initialPosition);

            innerEstimator.setReadings(innerReadings);

            // for preliminary solutions, non-linear solver is not needed, and if no
            // initial position is used, we can obtain faster solutions disabling
            // non-linear solver and using a linear one only (because covariance is not
            // required)
            innerEstimator.setNonLinearSolverEnabled(initialPosition != null);

            // indicates whether readings position covariances must be taken into account
            innerEstimator.setUseReadingPositionCovariances(useReadingPositionCovariances);

            innerEstimator.estimate();

            final var estimatedPosition = innerEstimator.getEstimatedPosition();
            solutions.add(new Solution&lt;&gt;(estimatedPosition));
        } catch (final NavigationException ignore) {
            // if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled, and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(final Solution&lt;Point2D&gt; result) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L258">258</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2294">2294</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point2D radioSourcePosition, final Point2D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 1st order Taylor expression of received power in 2D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();

        final var mean = new double[]{</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L758">758</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2294">2294</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point2D radioSourcePosition, final Point2D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance, final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance, final Matrix estimatedPositionCovariance)
            throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 2nd order Taylor expression of received power in 2D:
        // Pr(pi) = Pr(p1)
        //   - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //   - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //   - 5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
        //   - 5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2
        //   + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4))*(xi - x1)*(yi - y1)
        // where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();

        final var mean = new double[]{</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1887">1887</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2294">2294</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final Point2D estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathLossExponentVariance,
            final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance,
            final Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null || estimatedPosition == null) {
            return null;
        }

        // 3rd order Taylor expression of received power in 2D:
        // Pr(pi) = Pr(p1)
        //   -10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1) +
        //   -10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1) +
        //   -5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2 +
        //   -5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2 +
        //   20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1) +
        //   -10/6*n/ln(10)*(-2*(x1 - xa)*dia^4 - ((y1 - ya)^2 - (x1 - xa)^2)*4*d1a^2*(x1 - xa))/d1a^8*(xi - x1)^3 +
        //   -10/6*n/ln(10)*(-2*(y1 - ya)*d1a^4 - ((x1 - xa)^2 - (y1 - ya)^2)*4*d1a^2*(y1 - ya))/d1a^8*(yi - y1)^3 +
        //   -5*n/ln(10)*(2*(y1 - ya)*d1a^4 - ((y1 - ya)^2 - (x1 - xa)^2)*4*d1a^2*(y1 - ya))/d1a^8*(xi - x1)^2*(yi - y1) +
        //   -5*n/ln(10)*(2*(x1 - xa)*d1a^4 - ((x1 - xa)^2 - (y1 - ya)^2)*4*d1a^2*(x1 - xa))/d1a^8*(xi - x1)*(yi - y1)^2
        // where d1a2 = (x1 - xa)^2 + (y1 - ya)^2

        final var x1 = fingerprintPosition.getInhomX();
        final var y1 = fingerprintPosition.getInhomY();

        final var xa = radioSourcePosition.getInhomX();
        final var ya = radioSourcePosition.getInhomY();

        final var xi = estimatedPosition.getInhomX();
        final var yi = estimatedPosition.getInhomY();

        final var mean = new double[]{</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L423">423</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L941">941</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L458">458</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L965">965</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L475">475</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L959">959</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L498">498</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L275">275</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L502">502</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L423">423</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L941">941</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L458">458</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L943">943</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L965">965</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L475">475</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L958">958</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L498">498</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L501">501</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L941">941</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L458">458</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L941">941</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L458">458</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L943">943</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return MSACRobustRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L252">252</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L208">208</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] sampleIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(sampleIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return LMedSRobustRangingRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L254">254</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L206">206</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] sampleIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(sampleIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return LMedSRobustRangingRadioSourceEstimator3D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L477">477</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L428">428</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L943">943</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L460">460</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L967">967</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L477">477</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L961">961</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L500">500</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L277">277</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L504">504</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point2D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return LMedSRobustRssiRadioSourceEstimator2D.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L476">476</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L428">428</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L943">943</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L460">460</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L945">945</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L967">967</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L477">477</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L960">960</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L500">500</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L277">277</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L503">503</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return readings.size();
            }

            @Override
            public int getSubsetSize() {
                return Math.max(preliminarySubsetSize, getMinReadings());
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                solvePreliminarySolutions(samplesIndices, solutions);
            }

            @Override
            public double computeResidual(final Solution&lt;Point3D&gt; currentEstimation, final int i) {
                return residual(currentEstimation, i);
            }

            @Override
            public boolean isReady() {
                return LMedSRobustRssiRadioSourceEstimator3D.this.isReady();</pre></td></tr></table></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2021â€“2025
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
